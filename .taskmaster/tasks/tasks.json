{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Tauri + Next.js Project Structure",
        "description": "Set up the basic project structure with Tauri 2.7+ backend and Next.js 14+ frontend",
        "details": "Create Tauri project with Next.js frontend using `tauri init` command. Configure package.json with Next.js 14+, TypeScript 5+, and required dependencies. Set up src-tauri/Cargo.toml with kube-rs 1.1.0, tokio 1.46.1, serde 1.0.219, and Tauri plugins (fs, shell, dialog, store, updater, window-state, deep-link, log, os, opener). Configure tauri.conf.json for static export compatibility and multi-platform builds. Set up basic directory structure: src/app/, src/components/, src/lib/, src-tauri/src/commands/, src-tauri/src/k8s/",
        "testStrategy": "Verify project builds successfully with `pnpm tauri build`. Test that Next.js static export works. Confirm all Tauri plugins load correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Tauri project with Next.js frontend integration",
            "description": "Initialize Tauri 2.7+ project with Next.js 14+ frontend using tauri init command and configure basic project structure",
            "dependencies": [],
            "details": "Run 'tauri init' command to create the base Tauri project structure. Configure the project to use Next.js as the frontend framework. Set up the src-tauri directory with Cargo.toml and main.rs. Configure tauri.conf.json for Next.js integration with static export compatibility. Create the basic directory structure including src/ for frontend code and src-tauri/src/ for backend Rust code.",
            "status": "done",
            "testStrategy": "Verify project structure is created correctly and tauri dev command can be executed without errors",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure Next.js 14+ frontend with TypeScript and required dependencies",
            "description": "Set up Next.js 14+ with TypeScript 5+, App Router, and install required frontend dependencies for the Kubernetes management UI",
            "dependencies": [
              1
            ],
            "details": "Initialize Next.js project with App Router configuration. Install TypeScript 5+, React 18+, and required dependencies including @tauri-apps/api, @tauri-apps/plugin-* packages, Zustand for state management, TanStack Query for server state, React Hook Form, lucide-react for icons. Configure next.config.js for static export compatibility with Tauri. Set up TypeScript configuration and create basic directory structure: src/app/, src/components/, src/lib/, src/styles/.",
            "status": "done",
            "testStrategy": "Verify Next.js development server starts successfully and all dependencies are properly installed without conflicts",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure Rust backend with Kubernetes client and Tauri plugins",
            "description": "Set up Cargo.toml with kube-rs, tokio, serde, and all required Tauri plugins for Kubernetes operations",
            "dependencies": [
              1
            ],
            "details": "Configure src-tauri/Cargo.toml with kube-rs 1.1.0 for Kubernetes client functionality, tokio 1.46.1 for async runtime, serde 1.0.219 for serialization. Add Tauri plugins: tauri-plugin-fs, tauri-plugin-shell, tauri-plugin-dialog, tauri-plugin-store, tauri-plugin-updater, tauri-plugin-window-state, tauri-plugin-deep-link, tauri-plugin-log, tauri-plugin-os, tauri-plugin-opener. Include networking dependencies like reqwest, hyper, and security dependencies like rustls. Set up basic module structure in src-tauri/src/ with commands/, k8s/, and utils/ directories.",
            "status": "done",
            "testStrategy": "Verify Rust project compiles successfully and all dependencies resolve correctly with cargo check",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure Tauri application settings and build configuration",
            "description": "Set up tauri.conf.json with proper window settings, security policies, bundle configuration, and Next.js frontend integration",
            "dependencies": [
              2,
              3
            ],
            "details": "Configure tauri.conf.json with app metadata (productName: 'Kubeli', identifier: 'com.kubeli.app'), window settings (1400x900 default size, 1024x768 minimum), security CSP policies for web content, bundle targets for multi-platform builds (dmg, deb, appimage, msi). Set up build commands to use Next.js with 'beforeDevCommand' and 'beforeBuildCommand' pointing to Next.js scripts. Configure frontend distribution path to '../out' for static export. Enable required Tauri plugins in the configuration.",
            "status": "done",
            "testStrategy": "Verify tauri.conf.json is valid and tauri dev command launches the application window with Next.js content successfully",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create basic application structure and verify build process",
            "description": "Set up basic app layout, routing structure, and verify the complete build process works for all target platforms",
            "dependencies": [
              4
            ],
            "details": "Create src/app/layout.tsx as the root layout component with theme providers. Set up src/app/page.tsx as the main dashboard/home page. Create basic UI components in src/components/ui/ for buttons, cards, etc. Set up src/lib/tauri/ for IPC command wrappers. Configure package.json scripts for development and production builds. Create basic styling in src/styles/globals.css with light/dark theme support. Test the complete build process with 'pnpm build' and 'pnpm tauri build' to ensure static export works and produces distributable packages.",
            "status": "done",
            "testStrategy": "Verify complete build process succeeds for development and production, and that generated bundles can be installed and run correctly",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down the initialization task into: 1) Creating Tauri project with Next.js frontend integration, 2) Configuring Next.js 14+ frontend with TypeScript and required dependencies, 3) Configuring Rust backend with Kubernetes client and Tauri plugins, 4) Setting up tauri.conf.json with proper window settings and build configuration, 5) Creating basic application structure and verifying build process works for all target platforms",
        "updatedAt": "2025-12-12T19:43:25.825Z"
      },
      {
        "id": "2",
        "title": "Implement Kubernetes Client and Config Management",
        "description": "Create Rust backend for Kubernetes API client and kubeconfig file handling",
        "details": "Implement src-tauri/src/k8s/client.rs with kube-rs Client initialization. Create src-tauri/src/k8s/config.rs for parsing kubeconfig files from ~/.kube/config and custom paths. Support multiple contexts and clusters. Implement secure credential storage using OS keychain (Keychain on macOS, Secret Service on Linux, Credential Manager on Windows). Create Tauri commands: cluster:list, cluster:switch_context, cluster:get_namespaces, cluster:add_config. Handle authentication methods: client certificates, bearer tokens, exec plugins, OIDC.",
        "testStrategy": "Unit tests for kubeconfig parsing. Integration tests with minikube/kind cluster. Test context switching and namespace retrieval. Verify secure credential storage works on target platforms.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Rust dependencies and project structure for Kubernetes client",
            "description": "Initialize the Rust backend with required dependencies for Kubernetes API client and configure the basic project structure.",
            "dependencies": [],
            "details": "Add kube-rs, tokio, serde, and keyring crates to src-tauri/Cargo.toml. Create the k8s module directory structure: src-tauri/src/k8s/ with mod.rs file. Set up basic error handling types and common utilities. Configure Tauri features for async commands and enable necessary plugins for secure storage.",
            "status": "pending",
            "testStrategy": "Unit tests for dependency imports and basic module structure compilation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement kubeconfig parsing and context management",
            "description": "Create the config.rs module to handle kubeconfig file parsing, context switching, and cluster management.",
            "dependencies": [
              1
            ],
            "details": "Implement src-tauri/src/k8s/config.rs with functions to parse kubeconfig from ~/.kube/config and custom paths. Support multiple contexts and clusters with validation. Create structures for Config, Context, Cluster, and User. Implement context switching logic and current context detection. Handle edge cases like missing files and malformed configs.",
            "status": "pending",
            "testStrategy": "Unit tests with sample kubeconfig files. Test context switching and validation of malformed configs.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Kubernetes client initialization and connection management",
            "description": "Create the client.rs module for initializing kube-rs Client with proper authentication and connection handling.",
            "dependencies": [
              2
            ],
            "details": "Implement src-tauri/src/k8s/client.rs with Client initialization using kube-rs. Support multiple authentication methods: client certificates, bearer tokens, exec plugins, and OIDC. Create connection pooling and retry logic. Implement health checks and connection validation. Handle different cluster configurations and network timeouts.",
            "status": "pending",
            "testStrategy": "Integration tests with minikube/kind cluster. Test different authentication methods and connection scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement secure credential storage using OS keychain",
            "description": "Create secure credential storage system using platform-specific keychains for sensitive authentication data.",
            "dependencies": [
              3
            ],
            "details": "Implement credential storage using keyring crate for cross-platform support: Keychain on macOS, Secret Service on Linux, Credential Manager on Windows. Create functions to securely store and retrieve bearer tokens, client certificates, and other sensitive data. Implement credential encryption and secure deletion. Handle platform-specific edge cases and fallback mechanisms.",
            "status": "pending",
            "testStrategy": "Platform-specific tests for credential storage and retrieval. Test secure deletion and encryption on each OS.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Tauri commands for cluster operations and namespace management",
            "description": "Implement the complete set of Tauri commands for cluster management, context switching, and namespace operations.",
            "dependencies": [
              4
            ],
            "details": "Create Tauri commands: cluster:list, cluster:switch_context, cluster:get_namespaces, cluster:add_config. Implement proper error handling and response serialization. Add validation for command parameters and user inputs. Create async command handlers with proper cancellation support. Implement caching for frequently accessed data like namespace lists.",
            "status": "pending",
            "testStrategy": "Integration tests for all Tauri commands. Test error handling and parameter validation. Verify namespace retrieval works across different clusters.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Divide into: 1) Set up Rust dependencies and project structure for Kubernetes client, 2) Implement kubeconfig parsing and context management, 3) Implement Kubernetes client initialization and connection management, 4) Implement secure credential storage using OS keychain, 5) Create Tauri commands for cluster operations and namespace management",
        "updatedAt": "2025-12-12T20:27:00.973Z"
      },
      {
        "id": "3",
        "title": "Implement Resource Listing and Watching",
        "description": "Create backend commands for listing and watching Kubernetes resources with real-time updates",
        "details": "Implement src-tauri/src/commands/resources.rs with functions for listing pods, deployments, services, configmaps, secrets. Use kube-rs Api<T> for resource operations. Implement watch functionality using Kubernetes watch API with WebSocket streaming. Create resource:list, resource:get, resource:watch Tauri commands. Support filtering by namespace, labels, and field selectors. Implement pagination for large resource lists. Handle API errors gracefully and provide meaningful error messages. Use Tauri channels for streaming real-time updates to frontend.",
        "testStrategy": "Unit tests for resource listing logic. Integration tests with real Kubernetes cluster. Test watch functionality with resource creation/deletion. Verify pagination works with 100+ resources. Test error handling for invalid namespaces and RBAC denials.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create resource types and API structures",
            "description": "Define Rust structs and enums for Kubernetes resources and implement serialization",
            "dependencies": [],
            "details": "Create src-tauri/src/types/resources.rs with structs for Pod, Deployment, Service, ConfigMap, Secret. Implement serde serialization/deserialization. Define ResourceFilter struct for namespace, labels, and field selectors. Create ResourceList and ResourceWatch response types for frontend communication.",
            "status": "done",
            "testStrategy": "Unit tests for struct serialization and deserialization with sample Kubernetes API responses",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement core resource listing functionality",
            "description": "Build the resource:list Tauri command with filtering and pagination support",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/commands/resources.rs with resource_list function. Use kube-rs Api<T> to list pods, deployments, services, configmaps, secrets. Implement namespace filtering, label selectors, and field selectors. Add pagination with limit/offset parameters. Handle kube-rs errors and convert to user-friendly messages.",
            "status": "done",
            "testStrategy": "Integration tests with real Kubernetes cluster. Test filtering by namespace and labels. Verify pagination works with large resource lists.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement resource:get command for individual resources",
            "description": "Create functionality to retrieve detailed information for a specific resource",
            "dependencies": [
              1
            ],
            "details": "Add resource_get function in resources.rs to fetch individual resource details by name and namespace. Support all resource types (pods, deployments, services, configmaps, secrets). Include resource status, metadata, and spec information. Handle not found errors gracefully.",
            "status": "done",
            "testStrategy": "Unit tests for resource retrieval. Test error handling for non-existent resources and RBAC permission denials.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement WebSocket-based resource watching",
            "description": "Create real-time resource monitoring using Kubernetes watch API and WebSocket streaming",
            "dependencies": [
              2
            ],
            "details": "Implement resource_watch command using kube-rs watch API. Set up tokio channels for streaming updates to frontend via Tauri channels. Handle watch events (Added, Modified, Deleted). Implement reconnection logic for dropped connections. Support watching specific resource types or all resources in a namespace.",
            "status": "done",
            "testStrategy": "Integration tests with resource creation/deletion. Test watch functionality handles network interruptions. Verify multiple concurrent watches work independently.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add error handling and resource management",
            "description": "Implement comprehensive error handling and cleanup for resource operations",
            "dependencies": [
              4
            ],
            "details": "Add proper error handling for all resource commands with meaningful error messages. Implement cleanup for active watch connections when frontend disconnects. Add resource validation and RBAC error handling. Create stop_watch command to cleanly terminate watch streams. Add logging for debugging resource operations.",
            "status": "done",
            "testStrategy": "Test error scenarios including invalid namespaces, insufficient permissions, and network failures. Verify cleanup prevents memory leaks from abandoned watches.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Structure as: 1) Create resource types and API structures, 2) Implement core resource listing functionality, 3) Implement resource:get command for individual resources, 4) Implement WebSocket-based resource watching, 5) Add error handling and resource management",
        "updatedAt": "2025-12-12T20:31:12.753Z"
      },
      {
        "id": "4",
        "title": "Create Frontend Cluster and Resource Management UI",
        "description": "Build React frontend with 8-category navigation structure based on Kubeli's complete menu system for cluster connection and comprehensive resource viewing",
        "details": "Create src/app/layout.tsx with providers (Zustand, TanStack Query). Implement src/components/layout/Sidebar.tsx with 8-category navigation structure: Cluster (Overview, Nodes, Events, Namespaces, Lease), Helm (Releases), Workloads (Overview, Deployments, Pods, ReplicaSets, DaemonSets, StatefulSets, Jobs, CronJobs), Networking (Services, Ingresses, Endpoint Slices, Network Policies, Ingress Classes), Configuration (Secrets, ConfigMaps, HPA v2, Limit Ranges, Resource Quotas, Pod Disruption Budgets), Storage (Persistent Volume, Persistent Volume Claims, Volume Attachments, Storage Classes, CSI Drivers, CSI Nodes), Access Control (Service Accounts, Roles, Role Bindings, Cluster Roles, Cluster Role Bindings), Administration (CRDs, Priority Classes, Runtime Classes, Mutating Webhooks, Validating Webhooks). Build src/components/features/cluster/ClusterSelector.tsx for context switching. Create src/components/features/resources/ResourceList.tsx with table view, status indicators, search/filter functionality for all 49 resource types. Implement src/lib/hooks/useCluster.ts and src/lib/hooks/useK8sResources.ts for state management. Use TanStack Query for caching and real-time updates. Add loading states, error boundaries, and empty states for each resource category. Implement responsive design with CSS Modules or Tailwind CSS following Kubeli conventions.",
        "testStrategy": "Unit tests with React Testing Library for all components including navigation structure. Storybook stories for UI components across all 8 categories. E2E tests with Playwright for cluster connection flow and navigation between all menu sections. Test responsive design on different screen sizes. Verify real-time updates work correctly for all resource types. Test search and filtering functionality across different resource categories.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Next.js app layout with providers",
            "description": "Create the main app layout file with Zustand and TanStack Query providers for state management and data fetching",
            "dependencies": [],
            "details": "Create src/app/layout.tsx with proper TypeScript setup. Configure Zustand provider for global state management and TanStack Query provider for server state caching. Set up proper error boundaries and loading states. Include necessary imports and provider configuration for the entire application.",
            "status": "done",
            "testStrategy": "Unit tests to verify providers are properly configured and accessible throughout the app component tree",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement sidebar layout with 8-category navigation structure",
            "description": "Build the main sidebar component with complete Kubeli menu structure including all 8 categories and 49 sub-menus for comprehensive Kubernetes resource management",
            "dependencies": [
              1
            ],
            "details": "Create src/components/layout/Sidebar.tsx with hierarchical navigation structure: Cluster section (Overview, Nodes, Events, Namespaces, Lease), Helm section (Releases), Workloads section (Overview, Deployments, Pods, ReplicaSets, DaemonSets, StatefulSets, Jobs, CronJobs), Networking section (Services, Ingresses, Endpoint Slices, Network Policies, Ingress Classes), Configuration section (Secrets, ConfigMaps, HPA v2, Limit Ranges, Resource Quotas, Pod Disruption Budgets), Storage section (Persistent Volume, Persistent Volume Claims, Volume Attachments, Storage Classes, CSI Drivers, CSI Nodes), Access Control section (Service Accounts, Roles, Role Bindings, Cluster Roles, Cluster Role Bindings), Administration section (CRDs, Priority Classes, Runtime Classes, Mutating Webhooks, Validating Webhooks). Include cluster connection status, namespace selector dropdown, collapsible sections, and responsive design that collapses on mobile. Use CSS Modules or Tailwind for styling. Include proper accessibility attributes and keyboard navigation support for all menu items.",
            "status": "done",
            "testStrategy": "React Testing Library tests for component rendering, navigation structure, responsive behavior, accessibility compliance, and keyboard navigation through all menu categories",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build cluster selector and context switching",
            "description": "Create cluster selection component with connection management and context switching functionality",
            "dependencies": [
              2
            ],
            "details": "Implement src/components/features/cluster/ClusterSelector.tsx with dropdown for available clusters, connection status indicators, and context switching logic. Handle cluster connection errors and loading states. Integrate with Zustand store for cluster state management.",
            "status": "done",
            "testStrategy": "Unit tests for cluster switching logic, error handling, and integration tests with mock cluster data",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create comprehensive resource list component supporting all 49 resource types",
            "description": "Build the main resource list component with table display, status indicators, and search/filter functionality for all Kubernetes resource types across 8 categories",
            "dependencies": [
              3
            ],
            "details": "Implement src/components/features/resources/ResourceList.tsx with dynamic resource type handling for all 49 Kubernetes resource types. Create sortable table columns, resource status indicators (healthy, warning, error), search functionality, and filtering by resource type and category. Support resource-specific columns for each type (e.g., replicas for Deployments, type for Services, storage class for PVCs). Use virtualization for large lists. Include loading skeletons and empty states for each resource category. Add pagination or infinite scroll for performance. Implement category-based filtering and breadcrumb navigation.",
            "status": "done",
            "testStrategy": "Component tests for table functionality across all resource types, search/filter behavior for different categories, and performance tests with large datasets. Test resource-specific column rendering and status indicators for each resource type.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement custom hooks for comprehensive resource state management",
            "description": "Create custom React hooks for cluster and Kubernetes resource state management with TanStack Query integration supporting all resource categories",
            "dependencies": [
              4
            ],
            "details": "Build src/lib/hooks/useCluster.ts for cluster connection state, switching, and error handling. Implement src/lib/hooks/useK8sResources.ts with TanStack Query for caching, real-time updates, and background refetching for all 49 resource types across 8 categories. Create resource-specific hooks for complex resources like workloads, networking, and storage. Include optimistic updates and error recovery mechanisms. Add proper TypeScript types for all hook return values with resource-specific type definitions. Implement efficient caching strategies for different resource categories with appropriate cache invalidation.",
            "status": "done",
            "testStrategy": "Hook testing with React Testing Library hooks utilities, mock API responses for all resource types, and integration tests for real-time update functionality across different resource categories",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break into: 1) Set up Next.js app layout with providers, 2) Implement sidebar layout with 8-category navigation structure for all 49 sub-menus, 3) Build cluster selector and context switching, 4) Create comprehensive resource list component supporting all 49 resource types, 5) Implement custom hooks for comprehensive resource state management"
      },
      {
        "id": "5",
        "title": "Implement Log Streaming System",
        "description": "Build real-time log streaming from pods with WebSocket backend and frontend viewer supporting multi-container pods across all workload types",
        "details": "Implement src-tauri/src/commands/logs.rs using Kubernetes logs API with WebSocket streaming. Support follow mode, container selection for multi-container pods across all workload types (Deployments, DaemonSets, StatefulSets, Jobs, CronJobs), and historical log retrieval. Create Tauri commands: logs:stream, logs:stop, logs:download. Use tokio channels for async log streaming. Build src/components/features/logs/LogViewer.tsx with virtual scrolling for performance, text search/filtering, auto-scroll toggle, and color-coded log levels. Implement src/lib/hooks/useLogs.ts for managing multiple log streams from different workload types. Support downloading logs to file. Handle connection loss and auto-reconnect. Integrate with workload navigation structure for seamless log access from any pod-based resource.",
        "testStrategy": "Unit tests for log parsing and streaming logic. Integration tests with pods from different workload types that generate logs. Performance tests with high-volume log streams. Test container selection in multi-container pods across different workload types. Verify search functionality works with large log files. Test integration with workload navigation structure.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Kubernetes logs API backend commands",
            "description": "Create the Rust backend for Kubernetes log streaming with WebSocket support and async tokio channels",
            "dependencies": [],
            "details": "Implement src-tauri/src/commands/logs.rs with Tauri commands for logs:stream, logs:stop, and logs:download. Use the Kubernetes API client to access pod logs with follow mode support. Implement WebSocket streaming using tokio channels for async log processing. Support container selection for multi-container pods and historical log retrieval with proper error handling and connection management.",
            "status": "pending",
            "testStrategy": "Unit tests for log parsing logic and streaming mechanisms. Mock Kubernetes API responses for testing different log scenarios including multi-container pods.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create LogViewer React component with virtual scrolling",
            "description": "Build the frontend log viewer component with performance optimizations and user interaction features",
            "dependencies": [
              1
            ],
            "details": "Implement src/components/features/logs/LogViewer.tsx using virtual scrolling for handling large log volumes efficiently. Include text search and filtering capabilities, auto-scroll toggle functionality, and color-coded log levels (info, warn, error, debug). Add keyboard shortcuts for common actions and ensure proper accessibility support. Handle log stream state management and display connection status indicators.",
            "status": "pending",
            "testStrategy": "Component testing with React Testing Library for user interactions. Performance testing with large log datasets to verify virtual scrolling efficiency. Test search functionality across different log formats.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement useLogs React hook for stream management",
            "description": "Create a custom React hook to manage multiple simultaneous log streams and their state",
            "dependencies": [
              1
            ],
            "details": "Implement src/lib/hooks/useLogs.ts to handle multiple concurrent log streams from different pods/containers. Manage WebSocket connections, stream state (connecting, active, paused, error), and provide clean APIs for starting/stopping streams. Include automatic reconnection logic for dropped connections and memory management for log retention. Support downloading logs to local files with proper formatting.",
            "status": "pending",
            "testStrategy": "Hook testing with React Testing Library and Jest. Test multiple concurrent streams, connection recovery scenarios, and memory usage patterns with long-running streams.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add container selection and log filtering features",
            "description": "Implement UI controls for selecting containers in multi-container pods and filtering log content",
            "dependencies": [
              2,
              3
            ],
            "details": "Extend the LogViewer component with dropdown/selector for choosing specific containers within multi-container pods. Add filtering controls for log levels, timestamp ranges, and custom text patterns. Implement real-time filtering that works with the virtual scrolling system. Include preset filters for common log patterns and save/load custom filter configurations.",
            "status": "pending",
            "testStrategy": "Integration testing with multi-container test pods. Verify container selection updates log streams correctly. Test filter performance with high-volume log streams and complex filter combinations.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement log export and workload integration features",
            "description": "Add functionality to download, save, and manage log history with seamless integration to workload navigation structure",
            "dependencies": [
              1,
              3
            ],
            "details": "Implement log download functionality through the logs:download Tauri command with support for various formats (raw, JSON, CSV). Add local log caching for offline viewing and session persistence. Include compression for large log files and configurable retention policies. Handle connection loss gracefully with auto-reconnect and resume capabilities. Add progress indicators for large log operations. Integrate log viewer with workload navigation structure so users can access logs directly from Deployments, DaemonSets, StatefulSets, Jobs, and CronJobs resource lists and detail views.",
            "status": "pending",
            "testStrategy": "End-to-end testing of complete log streaming workflow from workload navigation. Test download functionality with large log files. Verify auto-reconnection works correctly after network interruptions. Performance testing with sustained high-volume log streams. Test integration with different workload types.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Organize into: 1) Implement Kubernetes logs API backend commands, 2) Create LogViewer React component with virtual scrolling, 3) Implement useLogs React hook for stream management, 4) Add container selection and log filtering features, 5) Implement log export and workload integration features"
      },
      {
        "id": "6",
        "title": "Implement Interactive Shell/Terminal Access",
        "description": "Create WebSocket-based terminal for executing commands in running containers across all workload types with integration to workload navigation structure",
        "details": "Implement src-tauri/src/commands/shell.rs using Kubernetes exec API with WebSocket. Support interactive shell sessions with proper terminal emulation (bash/sh) for containers in Deployments, DaemonSets, StatefulSets, Jobs, and CronJobs. Create shell:start, shell:send_input, shell:resize, shell:close Tauri commands. Handle terminal resize events and keyboard input. Build src/components/features/shell/Terminal.tsx using xterm.js for full terminal emulation. Support multiple concurrent shell sessions with tab management across different workload types. Implement copy/paste functionality and keyboard shortcuts. Handle session cleanup and reconnection on network issues. Integrate with workload navigation structure for seamless shell access from any pod-based resource.",
        "testStrategy": "Integration tests with containers from different workload types that have shell access. Test keyboard input handling and terminal resizing. Verify multiple sessions work independently across different workload types. Test copy/paste functionality. Ensure proper cleanup when sessions are closed. Test integration with workload navigation structure.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Kubernetes exec API WebSocket connection in shell.rs",
            "description": "Create the core WebSocket connection to Kubernetes exec API for interactive shell sessions with proper authentication and error handling.",
            "dependencies": [],
            "details": "Implement src-tauri/src/commands/shell.rs with WebSocket connection to Kubernetes exec API. Handle authentication using kubeconfig credentials. Implement connection establishment with proper error handling for network issues, authentication failures, and API errors. Set up bidirectional communication channels for stdin/stdout/stderr streams. Include connection timeout and retry logic.",
            "status": "pending",
            "testStrategy": "Unit tests for connection establishment and error handling. Integration tests with actual Kubernetes clusters to verify exec API communication.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Tauri commands for shell session management",
            "description": "Implement shell:start, shell:send_input, shell:resize, and shell:close Tauri commands for managing interactive shell sessions.",
            "dependencies": [
              1
            ],
            "details": "Create Tauri commands in shell.rs: shell:start for initiating sessions with container/pod selection, shell:send_input for sending keyboard input and commands, shell:resize for handling terminal resize events with proper dimensions, shell:close for graceful session termination. Implement session state management with unique session IDs and concurrent session support.",
            "status": "pending",
            "testStrategy": "Unit tests for each command with mock Kubernetes API. Integration tests with real containers to verify command execution and input handling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Terminal.tsx component with xterm.js integration",
            "description": "Create the frontend terminal component using xterm.js for full terminal emulation with proper rendering and interaction handling.",
            "dependencies": [
              2
            ],
            "details": "Implement src/components/features/shell/Terminal.tsx using xterm.js library. Set up terminal instance with proper size calculation, color scheme support, and cursor handling. Integrate with Tauri backend commands for bidirectional communication. Handle terminal resize events and keyboard input capture. Implement terminal options like font size, color themes, and cursor styles.",
            "status": "pending",
            "testStrategy": "Component tests for terminal rendering and input handling. E2E tests for terminal interaction with actual shell sessions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement multiple shell session management with tabs",
            "description": "Create tab-based interface for managing multiple concurrent shell sessions with proper session isolation and cleanup.",
            "dependencies": [
              3
            ],
            "details": "Build tab management system in Terminal.tsx for multiple concurrent shell sessions. Implement session isolation with unique identifiers, tab creation/closure handling, and active session switching. Add session cleanup logic for proper resource management when tabs are closed. Include visual indicators for session status (connected, disconnected, error states).",
            "status": "pending",
            "testStrategy": "Integration tests for multiple concurrent sessions. Test session isolation and cleanup. Verify tab management works correctly with many sessions.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add copy/paste functionality and workload integration",
            "description": "Implement clipboard operations and keyboard shortcuts for enhanced terminal usability with seamless integration to workload navigation structure",
            "dependencies": [
              4
            ],
            "details": "Implement copy/paste functionality in Terminal.tsx with proper text selection handling and clipboard API integration. Add keyboard shortcuts for common operations like Ctrl+C/Ctrl+V for copy/paste, Ctrl+Shift+T for new tab, Ctrl+W for close tab. Include context menu with copy/paste options. Handle special terminal key combinations and ensure they're passed through correctly to the shell session. Integrate terminal access with workload navigation structure so users can access shells directly from Deployments, DaemonSets, StatefulSets, Jobs, and CronJobs resource lists and detail views.",
            "status": "pending",
            "testStrategy": "Unit tests for keyboard shortcut handling and clipboard operations. User interaction tests for copy/paste functionality. Accessibility tests for keyboard navigation. Test integration with different workload types and navigation flow from resource lists to terminal access.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Structure as: 1) Implement Kubernetes exec API WebSocket connection in shell.rs, 2) Create Tauri commands for shell session management, 3) Build Terminal.tsx component with xterm.js integration, 4) Implement multiple shell session management with tabs, 5) Add copy/paste functionality and workload integration"
      },
      {
        "id": "7",
        "title": "Implement Port Forwarding Management",
        "description": "Build port forwarding system for accessing services locally with integration to networking and workload navigation structure",
        "details": "Implement src-tauri/src/commands/portforward.rs using Kubernetes port-forward API. Support forwarding from pods (across all workload types) and services (from Networking section) to localhost ports. Create portforward:start, portforward:stop, portforward:list Tauri commands. Handle auto-reconnection on connection loss and port conflict detection. Build src/components/features/portforward/PortForwardManager.tsx for managing active forwards. Show status indicators (connected, connecting, failed) and provide easy start/stop controls. Implement automatic port assignment and validation. Store active forwards in application state with persistence across app restarts. Integrate with both workload navigation (for pod forwarding) and networking navigation (for service forwarding) for seamless access from resource lists.",
        "testStrategy": "Integration tests with services and pods from different workload types that accept connections. Test port conflict handling and auto-reconnection. Verify forwarding works with both pods and services. Test persistence of port forwards across app restarts. Check error handling for invalid ports and resources. Test integration with workload and networking navigation structures.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement core Tauri backend for port forwarding",
            "description": "Create the Rust backend module with Kubernetes port-forward API integration and command handlers",
            "dependencies": [],
            "details": "Implement src-tauri/src/commands/portforward.rs with Kubernetes client library integration. Create portforward:start, portforward:stop, and portforward:list Tauri commands. Use tokio for async operations and handle WebSocket connections for port forwarding tunnels. Implement error handling for invalid resources, port conflicts, and connection failures. Set up proper logging and metrics collection for debugging port forwarding issues.",
            "status": "pending",
            "testStrategy": "Unit tests for command handlers and Kubernetes API integration. Mock Kubernetes client for testing edge cases. Test port conflict detection and error handling scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build port forwarding state management and persistence",
            "description": "Implement application state management for active port forwards with persistence across app restarts",
            "dependencies": [
              1
            ],
            "details": "Create data structures for tracking active port forwards including local port, remote port, target resource, and connection status. Implement state persistence using Tauri store plugin to maintain active forwards across application restarts. Add auto-reconnection logic with exponential backoff for failed connections. Implement status tracking (connected, connecting, failed, disconnected) and event emission for UI updates.",
            "status": "pending",
            "testStrategy": "Integration tests for state persistence and recovery. Test auto-reconnection behavior with simulated network failures. Verify state consistency across app restarts.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create PortForwardManager React component",
            "description": "Build the main UI component for managing port forwarding operations with status indicators and controls",
            "dependencies": [
              1
            ],
            "details": "Implement src/components/features/portforward/PortForwardManager.tsx using React hooks and state management. Create UI for listing active forwards, starting new forwards, and stopping existing ones. Add status indicators with color coding (green for connected, yellow for connecting, red for failed). Implement form validation for port numbers and resource selection. Add confirmation dialogs for destructive actions and toast notifications for operation results.",
            "status": "pending",
            "testStrategy": "Unit tests for component behavior and user interactions. Test form validation and error display. Verify status indicators update correctly based on backend state changes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement automatic port assignment and validation",
            "description": "Build intelligent port selection system with conflict detection and validation",
            "dependencies": [
              2
            ],
            "details": "Create automatic port assignment logic to find available local ports when not specified by user. Implement port validation to check for system reserved ports and conflicts with existing forwards. Add port range preferences and blacklist functionality. Create port availability checking using system calls to detect if ports are already in use by other applications. Implement retry logic for port assignment failures.",
            "status": "pending",
            "testStrategy": "Unit tests for port validation logic and conflict detection. Integration tests with actual port binding to verify availability checking. Test automatic assignment under various system conditions.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive error handling and navigation integration",
            "description": "Implement robust error handling, logging, and monitoring for port forwarding operations with seamless integration to workload and networking navigation structure",
            "dependencies": [
              3,
              4
            ],
            "details": "Add comprehensive error handling for all failure scenarios including network timeouts, Kubernetes API errors, and resource not found conditions. Implement detailed logging with structured data for debugging port forwarding issues. Add health monitoring for active forwards with periodic connectivity checks. Create user-friendly error messages and recovery suggestions. Implement circuit breaker pattern for repeated failures to prevent resource exhaustion. Integrate port forwarding with workload navigation structure (for pod forwarding from Deployments, DaemonSets, StatefulSets, etc.) and networking navigation structure (for service forwarding from Services section) for seamless access from resource lists and detail views.",
            "status": "pending",
            "testStrategy": "Error injection tests to verify all failure paths are handled gracefully. Test logging output format and completeness. Verify user error messages are helpful and actionable. Load testing with multiple concurrent forwards. Test integration with different workload types and networking resources.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Divide into: 1) Implement core Tauri backend for port forwarding, 2) Build port forwarding state management and persistence, 3) Create PortForwardManager React component, 4) Implement automatic port assignment and validation, 5) Add comprehensive error handling and navigation integration"
      },
      {
        "id": "8",
        "title": "Implement Resource Detail Views and YAML Editing",
        "description": "Create detailed resource views with YAML editing and update capabilities for all 49 resource types across 8 categories",
        "details": "Build src/components/features/resources/ResourceDetail.tsx showing complete resource information: metadata, spec, status, events, conditions for all resource types across 8 categories (Cluster, Helm, Workloads, Networking, Configuration, Storage, Access Control, Administration). Implement YAML editor with syntax highlighting using Monaco Editor or CodeMirror. Create resource:update, resource:delete, resource:apply Tauri commands supporting all resource types. Support different patch types (JSON Patch, Merge Patch, Strategic Merge Patch) for different resource kinds. Add validation for YAML syntax and Kubernetes schema for all resource types. Implement rollback functionality for failed updates. Show diff view when editing resources. Add confirmation dialogs for destructive operations. Include resource-specific detail views for complex resources like Deployments (replica status, conditions, events), Services (endpoints, ingress), PVCs (mounting status), etc.",
        "testStrategy": "Unit tests for YAML parsing and validation across all resource types. Integration tests for resource updates and deletions for each category. Test all patch types with different resource types from all 8 categories. Verify rollback functionality works correctly. Test error handling for invalid YAML and schema violations. Test resource-specific detail views for complex resources.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ResourceDetail Component Structure for all resource types",
            "description": "Build the main ResourceDetail.tsx component with sections for metadata, spec, status, events, and conditions display supporting all 49 resource types",
            "dependencies": [],
            "details": "Create src/components/features/resources/ResourceDetail.tsx with TypeScript interfaces for all resource types across 8 categories. Implement component structure with tabbed or accordion layout showing resource metadata (name, namespace, labels, annotations), spec configuration, current status, recent events, and condition states. Create resource-specific detail views for complex resources like Deployments (replica status, rollout history), Services (endpoints, selector), PVCs (mounting info), ConfigMaps/Secrets (data preview), etc. Use existing UI components from the component library for consistent styling.",
            "status": "pending",
            "testStrategy": "Unit tests for component rendering with mock resource data from all categories. Test different resource types (pods, services, deployments, configmaps, secrets, pvcs, etc.) render correctly with appropriate detail sections.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate YAML Editor with Kubernetes schema validation for all resource types",
            "description": "Implement Monaco Editor or CodeMirror for YAML editing with comprehensive Kubernetes schema validation for all resource kinds",
            "dependencies": [
              1
            ],
            "details": "Install and configure Monaco Editor or CodeMirror for YAML syntax highlighting. Add comprehensive Kubernetes schema validation covering all resource types from 8 categories to provide real-time feedback on YAML structure. Implement read-only and edit modes with resource-specific validation rules. Add line numbers, code folding, and find/replace functionality. Configure editor theme to match application theme. Include validation for resource-specific fields and constraints (e.g., port ranges for Services, storage sizes for PVCs, replica counts for Deployments).",
            "status": "pending",
            "testStrategy": "Test YAML syntax highlighting works correctly for all resource types. Verify schema validation catches invalid Kubernetes manifests for each resource kind. Test editor performance with large YAML files from complex resources like large Deployments or ConfigMaps.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Tauri Commands for comprehensive resource operations",
            "description": "Create backend Tauri commands for resource update, delete, and apply operations supporting all resource types with different patch strategies",
            "dependencies": [],
            "details": "Implement resource:update, resource:delete, and resource:apply commands in src-tauri/src/commands/resources.rs. Support JSON Patch, Merge Patch, and Strategic Merge Patch types for all resource kinds. Add proper error handling for network failures, permission issues, and invalid resources. Implement async operations with progress reporting. Handle resource-specific update constraints (e.g., immutable fields in PVCs, rolling update strategies for Deployments). Support all 49 resource types across 8 categories with appropriate API group and version handling.",
            "status": "pending",
            "testStrategy": "Integration tests for each patch type with test cluster using resources from all categories. Test error handling for invalid patches and network failures. Verify different resource types can be updated correctly with appropriate constraints and validations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Diff View and Update Confirmation System for all resource types",
            "description": "Create diff visualization component and confirmation dialogs for resource modifications supporting all resource kinds",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement diff view component showing before/after YAML changes with syntax highlighting for additions, deletions, and modifications for all resource types. Create confirmation dialogs for destructive operations (delete, replace) with resource-specific impact warnings (e.g., downtime warnings for Service deletion, data loss warnings for PVC deletion). Add preview mode that shows what changes will be applied before execution. Include resource-specific warnings and confirmations based on the resource type and operation impact.",
            "status": "pending",
            "testStrategy": "Test diff visualization with various types of changes across different resource categories. Verify confirmation dialogs prevent accidental destructive operations with appropriate warnings for each resource type. Test preview accuracy matches actual applied changes for all resource kinds.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Rollback and Error Recovery Features for all resource types",
            "description": "Add rollback functionality for failed updates and comprehensive error handling with recovery options supporting all resource kinds",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement automatic backup of resource state before modifications for all resource types. Create rollback mechanism that can restore previous resource state on failed updates. Add comprehensive error handling with user-friendly error messages and suggested recovery actions specific to each resource type (e.g., RBAC issues for Service Accounts, storage issues for PVCs, scheduling issues for Pods). Implement retry logic for transient failures with exponential backoff. Handle resource-specific rollback constraints and limitations (e.g., StatefulSet ordered updates, Job immutability).",
            "status": "pending",
            "testStrategy": "Test rollback functionality with intentionally failing updates across different resource types. Verify error messages are helpful and actionable for each resource kind. Test retry logic handles transient network issues correctly. Test resource-specific rollback scenarios and constraints.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Structure as: 1) Create ResourceDetail Component Structure for all resource types, 2) Integrate YAML Editor with Kubernetes schema validation for all resource types, 3) Implement Tauri Commands for comprehensive resource operations, 4) Build Diff View and Update Confirmation System for all resource types, 5) Implement Rollback and Error Recovery Features for all resource types",
        "updatedAt": "2025-12-13T11:46:42.934Z"
      },
      {
        "id": "9",
        "title": "Implement Application Settings and Preferences",
        "description": "Build comprehensive settings system with theme support, auto-update, and user preferences supporting all 8 resource categories",
        "details": "Create src/components/features/settings/SettingsPanel.tsx for user preferences with settings organized by the 8 main navigation categories. Implement light/dark theme switching with system theme detection. Add auto-update functionality using Tauri updater plugin with signature verification. Create settings for default namespace, refresh intervals for different resource types, log retention, and keyboard shortcuts. Configure category-specific preferences (e.g., default workload type views, networking resource polling rates, storage metrics display). Use Tauri store plugin for settings persistence. Implement src/lib/store/ui-store.ts for UI state management across all navigation categories. Add settings:get, settings:set, settings:reset Tauri commands. Support importing/exporting configuration. Include accessibility options and performance settings for handling large numbers of resources across all categories. Add window vibrancy level settings with validation/defaults and ensure persisted UI settings rehydrate with correct typing.",
        "testStrategy": "Unit tests for settings validation and persistence across all categories. Test theme switching works correctly. Verify auto-update mechanism with test server. Test settings import/export functionality. Check accessibility compliance with screen readers. Test category-specific settings work correctly with corresponding resource views.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Settings Panel Component with category-organized UI Framework",
            "description": "Build the main settings panel component organized by the 8 navigation categories that serves as the container for all settings sections",
            "dependencies": [],
            "details": "Create src/components/features/settings/SettingsPanel.tsx with tabbed or sectioned layout for organizing different settings categories. Include navigation between General, Appearance, Cluster Settings, Workloads Preferences, Networking Configuration, Storage Options, Access Control, Administration, and Advanced sections. Use React Hook Form for form management and Zustand for local settings state. Implement proper TypeScript interfaces for all settings data structures organized by resource categories. Follow existing component patterns in the codebase using functional components with proper error boundaries.",
            "status": "done",
            "testStrategy": "Unit tests for component rendering, navigation between tabs organized by categories, and form state management. Test accessibility with screen readers and keyboard navigation through all settings sections.",
            "parentId": "undefined",
            "updatedAt": "2025-12-13T12:29:20.215Z"
          },
          {
            "id": 2,
            "title": "Implement Theme System with Light/Dark Mode Support",
            "description": "Build comprehensive theme switching functionality with system theme detection and proper CSS variable management",
            "dependencies": [
              1
            ],
            "details": "Create src/lib/store/ui-store.ts with Zustand for theme state management. Implement theme detection using system preferences API through Tauri. Create CSS custom properties in src/styles/themes/ for light and dark themes following the existing styling approach. Add theme toggle component with system/light/dark options. Ensure all existing components work with both themes by using semantic color tokens instead of hardcoded colors. Implement theme persistence using Tauri store plugin.",
            "status": "done",
            "testStrategy": "Test theme switching works correctly, system theme detection functions properly, and theme persistence survives app restarts. Verify all UI components render correctly in both themes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-13T12:29:20.257Z"
          },
          {
            "id": 3,
            "title": "Build Auto-Update System with Tauri Updater Plugin",
            "description": "Implement secure auto-update functionality with signature verification and user control over update behavior",
            "dependencies": [
              1
            ],
            "details": "Configure tauri-plugin-updater in Cargo.toml and tauri.conf.json with proper endpoints and public key for signature verification. Create update check logic in Rust backend with scheduled checks and manual check capability. Add settings UI for update preferences (auto-install, check frequency, beta channel). Implement update notification system with progress indicators and restart prompts. Create fallback mechanisms for update failures and network issues. Harden update check logic and error handling for reliability. Add logging for update operations using tauri-plugin-log.",
            "status": "done",
            "testStrategy": "Test auto-update mechanism with test server, verify signature validation works correctly, and ensure update notifications appear properly. Test update rollback and error handling scenarios.",
            "parentId": "undefined",
            "updatedAt": "2025-12-13T17:37:56.057Z"
          },
          {
            "id": 4,
            "title": "Create Application Preferences and category-specific Settings Storage",
            "description": "Implement comprehensive user preferences system with persistent storage for all application settings organized by resource categories",
            "dependencies": [
              2
            ],
            "details": "Create settings schema for default namespace, refresh intervals for different resource categories (5s, 10s, 30s), log retention (1000, 5000, 10000 lines), keyboard shortcuts, and accessibility options. Add category-specific preferences: Cluster (default views, node metrics), Workloads (polling rates, replica status display), Networking (service discovery, ingress monitoring), Storage (capacity warnings, mount status), Configuration (secret masking, configmap formatting), Access Control (RBAC validation), Administration (CRD handling, webhook monitoring). Use tauri-plugin-store for secure settings persistence with encryption. Implement settings validation and migration system for version updates. Add import/export functionality for configuration backup and sharing. Create Tauri commands: settings:get, settings:set, settings:reset for IPC communication. Include performance settings like virtual scrolling thresholds and resource polling intervals per category. Add vibrancy level preference with validation/defaults and ensure persisted settings rehydrate with correct types.",
            "status": "done",
            "testStrategy": "Unit tests for settings validation and persistence across all categories. Test import/export functionality works correctly. Verify settings reset restores defaults and settings survive app updates. Check edge cases with invalid configuration data. Test category-specific settings apply correctly to corresponding resource views.",
            "parentId": "undefined",
            "updatedAt": "2025-12-13T12:29:20.296Z"
          },
          {
            "id": 5,
            "title": "Add Accessibility and Performance Configuration Options for all resource categories",
            "description": "Implement accessibility features and performance tuning options to ensure the application works well for all users and different hardware configurations across all resource categories",
            "dependencies": [
              4
            ],
            "details": "Add accessibility settings including high contrast mode, reduced motion preferences, screen reader optimizations, and custom font sizing options. Implement performance settings for resource polling intervals per category, virtual scrolling parameters for large resource lists, log buffer sizes, and connection timeouts. Create keyboard shortcuts management with customizable key bindings for common operations across all resource categories. Add debug mode toggle for development features and verbose logging. Integrate with system accessibility APIs through Tauri for proper screen reader support and system integration. Include category-specific performance tuning (e.g., workload update frequencies, networking discovery intervals, storage monitoring rates).",
            "status": "done",
            "testStrategy": "Test accessibility compliance with screen readers (NVDA, JAWS, VoiceOver). Verify performance settings actually improve performance on lower-end hardware across all resource categories. Test keyboard shortcuts work correctly and don't conflict with system shortcuts. Ensure reduced motion settings respect user preferences. Test category-specific performance settings work correctly with corresponding resource views.",
            "parentId": "undefined",
            "updatedAt": "2025-12-13T12:29:26.452Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Organize into: 1) Create Settings Panel Component with category-organized UI Framework, 2) Implement Theme System with Light/Dark Mode Support, 3) Build Auto-Update System with Tauri Updater Plugin, 4) Create Application Preferences and category-specific Settings Storage, 5) Add Accessibility and Performance Configuration Options for all resource categories",
        "updatedAt": "2025-12-13T17:37:56.057Z"
      },
      {
        "id": "10",
        "title": "Implement Application Packaging and Distribution",
        "description": "Set up build pipeline for cross-platform distribution with code signing supporting the complete Kubeli application with all 8 resource categories",
        "details": "Configure Tauri build for macOS (.dmg), Linux (.deb, .AppImage), and Windows (.msi) distributions. Set up code signing for all platforms: Apple Developer ID for macOS, GPG signing for Linux packages, Authenticode for Windows. Create GitHub Actions workflow for automated builds and releases. Implement update manifest server endpoint for auto-updates. Configure bundle optimizations to keep installer size under 50MB despite supporting all 49 resource types. Set up crash reporting and telemetry collection (opt-in) with category-specific metrics. Create installation documentation and system requirements. Add uninstaller for Windows and cleanup scripts. Include application metadata reflecting the complete Kubeli feature set with all navigation categories.",
        "testStrategy": "Test installation and uninstallation on all target platforms with full application functionality. Verify code signatures are valid. Test auto-update mechanism end-to-end. Check bundle sizes meet requirements despite comprehensive feature set. Test with different OS versions and configurations. Verify all 8 resource categories and 49 resource types work correctly after installation.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Tauri build system for cross-platform distribution with complete feature set",
            "description": "Set up Cargo.toml and tauri.conf.json with platform-specific build targets and bundle configurations supporting all Kubeli features",
            "dependencies": [],
            "details": "Create initial Tauri configuration files including Cargo.toml with necessary dependencies (tauri-plugin-updater, tauri-plugin-store, etc.), tauri.conf.json with bundle configurations for macOS (.dmg), Linux (.deb, .AppImage), and Windows (.msi). Configure build targets, app metadata reflecting Kubeli branding and complete feature set, and installer icons. Set up bundle identifiers and minimum system requirements for each platform. Include all necessary dependencies for supporting 49 resource types across 8 categories.",
            "status": "pending",
            "testStrategy": "Verify configuration files validate successfully with tauri build --help. Test build process on each platform using GitHub Actions runners. Verify all features work correctly in built packages.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement code signing for all target platforms",
            "description": "Set up platform-specific code signing with Apple Developer ID, GPG signing, and Windows Authenticode",
            "dependencies": [
              1
            ],
            "details": "Configure Apple Developer ID signing for macOS builds with proper entitlements and notarization workflow. Set up GPG key management for Linux package signing. Implement Windows Authenticode signing with certificate storage. Create environment variable configuration for CI/CD pipeline to handle signing credentials securely. Add signing verification steps to build process.",
            "status": "pending",
            "testStrategy": "Verify signed binaries with platform-specific verification tools (codesign -v on macOS, gpg --verify on Linux, signtool verify on Windows). Test installation on fresh systems.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create GitHub Actions workflow for automated builds and releases",
            "description": "Build CI/CD pipeline for cross-platform building, signing, and artifact distribution",
            "dependencies": [
              2
            ],
            "details": "Create .github/workflows/release.yml with matrix builds for macOS, Linux, and Windows. Configure runner environments with necessary dependencies (Rust toolchain, Node.js, platform-specific signing tools). Implement artifact uploading, release creation, and automated changelog generation. Add conditional triggers for tags and pull requests. Configure secrets management for signing certificates and keys.",
            "status": "done",
            "testStrategy": "Test workflow with draft releases. Verify artifacts are properly signed and installable on target platforms. Check that builds complete within reasonable time limits (< 30 minutes total).",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T13:46:50.288Z"
          },
          {
            "id": 4,
            "title": "Implement update manifest server endpoint and auto-update mechanism",
            "description": "Build auto-update server endpoint and client-side update checking using Tauri updater plugin",
            "dependencies": [
              1
            ],
            "details": "Create update manifest server endpoint that serves JSON with version information, download URLs, and signatures. Implement Tauri-side update checking logic using tauri-plugin-updater with signature verification. Add user preferences for auto-update settings (enabled/disabled, check frequency). Create update notification UI with download progress and installation prompts. Handle update failures gracefully with rollback capability.",
            "status": "pending",
            "testStrategy": "Test update mechanism end-to-end with staging server. Verify signature validation prevents malicious updates. Test update process on all platforms including edge cases like network interruption.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize bundle size and implement comprehensive telemetry collection system",
            "description": "Reduce installer size under 50MB and add opt-in crash reporting and usage analytics with category-specific metrics for all resource types",
            "dependencies": [
              3,
              4
            ],
            "details": "Analyze bundle composition and remove unnecessary dependencies while preserving support for all 49 resource types. Implement tree-shaking for frontend code and minimize Rust binary size with optimization flags. Add opt-in telemetry collection for crash reports and usage analytics using secure endpoints with category-specific metrics (e.g., most used resource types, navigation patterns, performance metrics per category). Create privacy-compliant data collection with user consent management. Implement uninstaller for Windows and cleanup scripts for all platforms. Add installation documentation with system requirements and feature overview covering all 8 navigation categories.",
            "status": "pending",
            "testStrategy": "Verify final bundle sizes meet <50MB requirement despite comprehensive feature set. Test telemetry collection respects user preferences and provides useful category-specific insights. Validate uninstaller completely removes application data. Test installation documentation accuracy on clean systems. Verify all resource categories work correctly after installation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break into: 1) Configure Tauri build system for cross-platform distribution with complete feature set, 2) Implement code signing for all target platforms, 3) Create GitHub Actions workflow for automated builds and releases, 4) Implement update manifest server endpoint and auto-update mechanism, 5) Optimize bundle size and implement comprehensive telemetry collection system",
        "updatedAt": "2025-12-30T13:46:50.288Z"
      },
      {
        "id": "11",
        "title": "Implement Cluster Resources Views",
        "description": "Build views for Events, Namespaces, and Leases cluster resources",
        "details": "Implement the remaining Cluster category resources. Create EventsView with real-time event streaming, filtering by type/reason/involved object, and timeline visualization. Build NamespacesView with namespace management (create/delete), resource quota display, and quick namespace switching. Implement LeasesView showing leader election status for control plane components. Add backend commands for listing and watching these resources. Include proper error handling and empty states.",
        "testStrategy": "Test event streaming with various cluster activities. Verify namespace creation/deletion works correctly. Test lease information displays accurately for HA clusters.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "updatedAt": "2025-12-30T04:44:27.300Z"
      },
      {
        "id": "12",
        "title": "Implement Helm Releases Management",
        "description": "Build comprehensive Helm releases management with install, upgrade, rollback capabilities",
        "details": "Create HelmReleasesView showing all Helm releases across namespaces. Display release status, chart version, app version, and revision history. Implement release actions: upgrade, rollback, uninstall. Add values editor with diff view for upgrades. Show release notes and computed values. Implement Rust backend using helm-rs or direct Helm API integration. Support adding Helm repositories and browsing available charts.",
        "testStrategy": "Test with various Helm releases. Verify upgrade/rollback functionality. Test repository management and chart installation.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "updatedAt": "2025-12-30T13:17:01.949Z"
      },
      {
        "id": "13",
        "title": "Implement Extended Workload Resources",
        "description": "Build views for ReplicaSets, DaemonSets, StatefulSets, Jobs, and CronJobs",
        "details": "Implement WorkloadsOverview with aggregated status of all workload types. Create ReplicaSetsView showing replica sets with owner references to deployments. Build DaemonSetsView with node scheduling status and update strategy display. Implement StatefulSetsView with ordered pod management and persistent volume claims. Create JobsView with completion status, parallelism settings, and pod logs access. Build CronJobsView with schedule display, last execution time, and manual trigger capability. Add backend commands for all resource types.",
        "testStrategy": "Test each workload type with various configurations. Verify status indicators are accurate. Test job triggering and completion tracking.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2025-12-30T05:07:53.888Z"
      },
      {
        "id": "14",
        "title": "Implement Extended Networking Resources",
        "description": "Build views for Ingresses, Endpoint Slices, Network Policies, and Ingress Classes",
        "details": "Create IngressesView with routing rules display, TLS configuration, and backend service links. Implement EndpointSlicesView showing service endpoints with health status. Build NetworkPoliciesView with ingress/egress rules visualization and affected pods display. Create IngressClassesView for managing ingress controller configurations. Add backend commands with proper API group handling (networking.k8s.io).",
        "testStrategy": "Test ingress routing display. Verify network policy visualization. Test endpoint slice health indicators.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2026-01-17T07:41:49.066Z"
      },
      {
        "id": "15",
        "title": "Implement Extended Configuration Resources",
        "description": "Build views for HPA, Limit Ranges, Resource Quotas, and Pod Disruption Budgets",
        "details": "Create HPAView (v2) with current/target metrics display, scaling history, and recommendations. Build LimitRangesView showing default/max/min limits per resource type. Implement ResourceQuotasView with usage vs quota visualization and alerts for near-limit resources. Create PodDisruptionBudgetsView with disruption status and affected workloads. Add backend commands with metrics API integration for HPA.",
        "testStrategy": "Test HPA scaling behavior display. Verify quota usage calculations. Test PDB status during rolling updates.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2025-12-30T13:32:11.224Z"
      },
      {
        "id": "16",
        "title": "Implement Storage Resources",
        "description": "Build views for PV, PVC, Volume Attachments, Storage Classes, CSI Drivers, and CSI Nodes",
        "details": "Create PersistentVolumesView with capacity, access modes, reclaim policy, and bound PVC display. Build PersistentVolumeClaimsView with storage class, capacity, and mounting pod information. Implement VolumeAttachmentsView showing CSI volume attachment status. Create StorageClassesView with provisioner, parameters, and default class indicator. Build CSIDriversView and CSINodesView for CSI infrastructure monitoring. Add storage-specific backend commands.",
        "testStrategy": "Test PV/PVC binding display. Verify storage class provisioning info. Test CSI driver capabilities display.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2025-12-30T05:48:50.915Z"
      },
      {
        "id": "17",
        "title": "Implement Access Control Resources",
        "description": "Build views for Service Accounts, Roles, Role Bindings, Cluster Roles, and Cluster Role Bindings",
        "details": "Create ServiceAccountsView with associated secrets, image pull secrets, and token management. Build RolesView and ClusterRolesView with rules display (verbs, resources, API groups). Implement RoleBindingsView and ClusterRoleBindingsView showing subject-to-role mappings. Add RBAC analyzer to show effective permissions for a user/service account. Include backend commands for RBAC resources with proper authorization checks.",
        "testStrategy": "Test RBAC rules display. Verify role binding relationships. Test effective permissions calculation.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "updatedAt": "2025-12-30T06:13:12.234Z"
      },
      {
        "id": "18",
        "title": "Implement Administration Resources",
        "description": "Build views for CRDs, Priority Classes, Runtime Classes, and Webhooks",
        "details": "Create CRDsView with custom resource definitions, versions, and schema display. Allow browsing and managing custom resource instances. Build PriorityClassesView with preemption policy and value display. Implement RuntimeClassesView showing container runtime configurations. Create MutatingWebhooksView and ValidatingWebhooksView with webhook rules, failure policy, and call statistics. Add backend commands for all admin resources. See openspec/specs/crd-management/spec.md for detailed CRD requirements.",
        "testStrategy": "Test CRD listing and custom resource browsing. Verify webhook configuration display. Test priority class ordering.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "updatedAt": "2025-12-30T06:13:12.237Z"
      },
      {
        "id": "19",
        "title": "Implement Advanced Log Viewer Features",
        "description": "Enhance log viewer with advanced search, multi-pod tailing, and log aggregation",
        "details": "Add regex search and highlighting in log viewer. Implement multi-pod log tailing for deployments (aggregate logs from all pods). Add log level filtering with color coding. Implement log bookmarking and annotation. Add export to various formats (plain text, JSON, with timestamps). Create log comparison view for debugging. Add log streaming from init containers and previous container instances.",
        "testStrategy": "Test regex search performance. Verify multi-pod aggregation ordering. Test export functionality with large logs.",
        "priority": "low",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "updatedAt": "2025-12-30T13:44:42.176Z"
      },
      {
        "id": "20",
        "title": "Implement Resource Favorites and Quick Access",
        "description": "Add ability to favorite/pin resources for quick access across the application",
        "details": "Create favorites system allowing users to pin frequently accessed resources. Add favorites section in sidebar with quick navigation. Implement recent resources history. Add keyboard shortcuts for favorite resources (Cmd+1 through Cmd+9). Store favorites per cluster context. Add drag-and-drop reordering of favorites. Include favorite groups/folders for organization.",
        "testStrategy": "Test favorite persistence across sessions. Verify keyboard shortcuts work correctly. Test favorites with different resource types.",
        "priority": "low",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "updatedAt": "2025-12-30T13:41:18.510Z"
      },
      {
        "id": "21",
        "title": "Implement Auto-Reconnect and Connection Health",
        "description": "Add automatic reconnection on cluster disconnect and connection health monitoring",
        "details": "Implement connection health monitoring with periodic API server pings. Add automatic reconnection with exponential backoff when connection is lost. Show connection status indicator with latency information. Add offline mode with cached data display. Implement graceful degradation when cluster is unreachable. Add connection retry controls in UI. Store and restore watch subscriptions after reconnection. See openspec/specs/auto-reconnect/spec.md for detailed requirements.",
        "testStrategy": "Test reconnection after network interruption. Verify watch subscriptions restore correctly. Test offline mode data display.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "updatedAt": "2025-12-30T06:17:16.677Z"
      },
      {
        "id": "22",
        "title": "Implement Metrics Monitoring and Charts",
        "description": "Build real-time resource metrics visualization for nodes and pods including CPU, memory usage charts",
        "details": "Implement src-tauri/src/k8s/metrics.rs for fetching metrics from Kubernetes Metrics API. Create Tauri commands: metrics:get_node_metrics, metrics:get_pod_metrics, metrics:get_cluster_summary. Build frontend components for real-time charts showing CPU and memory usage with sparklines and historical data. Display metrics in Node and Pod detail views. Show cluster-wide resource utilization in Cluster Overview. Implement metrics polling with configurable intervals. Handle metrics-server unavailability gracefully. See openspec/specs/metrics-monitoring/spec.md for detailed requirements.",
        "testStrategy": "Test metrics fetching with metrics-server installed. Verify chart updates in real-time. Test graceful degradation when metrics-server is unavailable. Performance test with large clusters.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2025-12-14T15:37:11.891Z"
      },
      {
        "id": "23",
        "title": "Implement Proxy Support",
        "description": "Enable connecting to Kubernetes clusters through HTTP and SOCKS proxies for corporate environments",
        "details": "Implement src-tauri/src/network/proxy.rs for proxy configuration management. Support HTTP, HTTPS, SOCKS4, and SOCKS5 proxies. Add system proxy detection for macOS, Windows, and Linux. Create per-cluster proxy settings with global defaults. Implement proxy authentication with secure credential storage. Add proxy settings UI in Settings > Network. Create proxy connection testing functionality. Add hyper-http-proxy and hyper-socks2 dependencies. See openspec/specs/proxy-support/spec.md for detailed requirements.",
        "testStrategy": "Test HTTP and SOCKS proxy connections. Verify system proxy detection on all platforms. Test proxy authentication. Verify per-cluster proxy settings work correctly.",
        "priority": "low",
        "dependencies": [
          "2",
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2025-12-30T14:01:21.643Z"
      },
      {
        "id": "24",
        "title": "Implement AI Assistant Integration with Claude Agent SDK",
        "description": "Build intelligent AI assistant using Claude Agent SDK (not raw API) that can autonomously analyze cluster resources, diagnose issues, and suggest remediation",
        "details": "CRITICAL: Use Claude Agent SDK via `claude_agent_sdk` Rust crate - NOT the raw Claude API. The Agent SDK provides autonomous tool loop, context management, and multi-step workflow execution.\n\nRust Implementation:\n- Create src-tauri/src/ai/agent_manager.rs with AgentManager struct for process lifecycle\n- Use tokio::process::Command to spawn claude CLI in Agent Mode\n- Implement ClaudeSDKClient for stateful bi-directional streaming connection\n- Store Session IDs in SQLite (rusqlite) for session persistence and resume capability\n- Implement PermissionCallback trait for security guardrails\n\nPermission Modes (Defense-in-Depth):\n1. Plan (Default): Agent proposes commands, user must approve\n2. Default (Human-in-the-Loop): Safe commands (get, describe) auto-execute, destructive (delete, apply) require approval\n3. AcceptEdits: Full autonomy for sandboxed namespaces only\n\nHook-Based Guardrails:\n- PreToolUse hook inspects commands before execution\n- Regex matching for dangerous operations (rm -rf, kubectl delete)\n- Frontend modal via tauri://event for approval requests\n- Agent process suspended until user responds\n\nVirtual Context Strategy (Dynamic CLAUDE.md):\n- Generate ephemeral context when connecting to cluster\n- Include: Cluster Topology ('v1.28 on EKS'), Operational Constraints ('No deletes in kube-system'), Tool Availability\n- Inject via Agent SDK initialization options\n\nFrontend:\n- Create src/components/features/ai/AIAssistant.tsx with streaming chat interface\n- Support Extended Thinking display and interruptibility\n- Show tool execution steps and approval requests\n- Persist conversation history per cluster in SQLite\n\nTauri Commands:\n- ai:start_session, ai:send_message, ai:interrupt, ai:resume_session\n- ai:set_permission_mode, ai:approve_action, ai:reject_action",
        "testStrategy": "Test Agent SDK integration with various cluster states. Verify Permission Modes enforce correct security. Test session persistence and resume. Verify PreToolUse hooks block dangerous commands. Test streaming responses and interruptibility. Performance test with large context windows.",
        "priority": "high",
        "dependencies": [
          "5",
          "22"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Claude Code CLI Detection and Authentication",
            "description": "Implement detection of Claude Code CLI installation and verify authentication status with fallback to manual API key input",
            "dependencies": [],
            "details": "Create src-tauri/src/ai/cli_detector.rs that checks if `claude` CLI is available in PATH using tokio::process::Command. Verify authentication by running `claude --version` and parsing output. Improve CLI path detection for common version managers and update installation instructions. Store API key fallback in Tauri plugin-store. Add Tauri commands: ai:check_cli_available, ai:verify_authentication, ai:set_api_key. Create frontend settings UI component in src/components/features/settings/AISettings.tsx with status indicator (green=authenticated, yellow=CLI missing, red=no auth) and manual API key input field. Use existing command pattern from src/lib/tauri/commands.ts.",
            "status": "done",
            "testStrategy": "Test CLI detection on system with/without Claude Code installed. Verify authentication check returns correct status. Test manual API key input and storage. Verify error handling for invalid API keys.",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T14:14:41.068Z"
          },
          {
            "id": 2,
            "title": "AgentManager Rust Implementation with Claude SDK Integration",
            "description": "Build AgentManager struct for managing Claude Agent SDK process lifecycle and bi-directional streaming",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/ai/agent_manager.rs with AgentManager struct. Add dependencies to Cargo.toml: rusqlite for session persistence, tokio-process for subprocess management. Implement spawn_agent() using tokio::process::Command to start claude CLI in Agent Mode with --agent flag. Create ClaudeSDKClient wrapper for stdin/stdout streaming communication using tokio_util::codec. Implement agent lifecycle methods: start_session(), send_message(), interrupt(), shutdown(). Store active agent process handles in Arc<Mutex<HashMap<String, Child>>>. Follow existing manager patterns from LogStreamManager and ShellSessionManager in src-tauri/src/commands/. Add to mod.rs and register in main.rs similar to existing managers.",
            "status": "done",
            "testStrategy": "Test agent process spawning and lifecycle management. Verify stdin/stdout streaming works correctly. Test graceful shutdown and error recovery. Verify concurrent session handling with multiple agents.",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T14:18:06.657Z"
          },
          {
            "id": 3,
            "title": "Permission System and Security Guardrails",
            "description": "Implement three-tier permission modes (Plan/Default/AcceptEdits) with PreToolUse hooks for dangerous command detection",
            "dependencies": [
              2
            ],
            "details": "Create src-tauri/src/ai/permissions.rs with PermissionMode enum (Plan, Default, AcceptEdits). Implement PermissionCallback trait with pre_tool_use() hook that inspects kubectl commands before execution. Add regex patterns for dangerous operations: kubectl delete in restricted namespaces (kube-system, kube-public), kubectl apply with cluster-scoped resources, rm -rf patterns. Implement approval flow: when dangerous command detected, emit tauri://ai_approval_required event to frontend with command details. Frontend displays modal (use existing dialog.tsx pattern) with Allow/Deny buttons. Backend waits for user response via ai:approve_action or ai:reject_action commands. Store permission mode per cluster context in SQLite. Add namespace sandbox validation for AcceptEdits mode.",
            "status": "done",
            "testStrategy": "Test each permission mode enforces correct restrictions. Verify regex patterns catch all dangerous operations. Test approval modal workflow end-to-end. Verify sandboxed namespaces in AcceptEdits mode. Test denied command handling.",
            "parentId": "undefined",
            "updatedAt": "2026-01-01T14:26:52.210Z"
          },
          {
            "id": 4,
            "title": "Virtual Context Strategy with Dynamic CLAUDE.md Generation",
            "description": "Implement dynamic context injection for agent initialization with cluster-specific topology and operational constraints",
            "dependencies": [
              2
            ],
            "details": "Create src-tauri/src/ai/context_builder.rs that generates ephemeral CLAUDE.md content when connecting to cluster. Gather cluster metadata: Kubernetes version from server info API, cluster type detection (EKS/GKE/AKS via node labels), resource counts (nodes, namespaces, pods). Build context sections: [Cluster Topology] with version and platform info, [Operational Constraints] with permission mode rules and restricted namespaces, [Available Tools] listing kubectl commands and kube-rs capabilities, [Current State] with active namespace and recent events. Inject context via Agent SDK initialization options or environment variables. Store context templates in src-tauri/templates/agent-context.md. Update context when cluster connection changes using existing cluster-store.ts subscription pattern.",
            "status": "done",
            "testStrategy": "Test context generation with various cluster types (minikube, EKS, GKE). Verify all metadata is correctly gathered. Test context injection reaches agent. Verify context updates on cluster switch.",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T14:25:10.911Z"
          },
          {
            "id": 5,
            "title": "Frontend AI Chat Interface with Streaming and Thinking Display",
            "description": "Build React component for AI assistant with streaming responses, Extended Thinking visualization, and conversation history",
            "dependencies": [
              2,
              3
            ],
            "details": "Create src/components/features/ai/AIAssistant.tsx as main chat interface following existing component patterns. Use Card, ScrollArea, and Button from src/components/ui/. Implement message list with user/assistant bubbles. Add streaming message support with useEffect listening to tauri://ai_message_chunk events. Create ThinkingIndicator component showing Extended Thinking status with animated spinner (use existing spinner.tsx). Add message action buttons: Copy, Regenerate, Interrupt (calls ai:interrupt command). Build input area with Textarea and Send button, support Shift+Enter for newlines. Create src/lib/stores/ai-store.ts Zustand store for conversation state following cluster-store.ts pattern. Add conversation history persistence using tauri-plugin-store. Display tool execution steps as collapsible items in message stream. Wire up approval modals from permission system.",
            "status": "done",
            "testStrategy": "Test streaming message display with various response types. Verify Extended Thinking indicator shows/hides correctly. Test message persistence and history loading. Verify approval modal integration. Test interrupt functionality. Verify responsive layout.",
            "parentId": "undefined",
            "updatedAt": "2025-12-30T14:22:03.089Z"
          },
          {
            "id": 6,
            "title": "Session Persistence and Resume Capability",
            "description": "Implement SQLite storage for agent sessions with resume functionality and per-cluster conversation history",
            "dependencies": [
              2,
              5
            ],
            "details": "Add rusqlite dependency to Cargo.toml. Create src-tauri/src/ai/session_store.rs with SessionStore struct. Define sessions table schema: session_id (primary key), cluster_context, created_at, last_active_at, permission_mode, conversation_history (JSON blob). Define messages table: message_id, session_id, role (user/assistant), content, tool_calls (JSON), timestamp. Implement save_session(), load_session(), list_sessions_for_cluster(), delete_session(). Add resume logic in AgentManager that reinitializes agent with historical context from conversation_history. Create Tauri commands: ai:list_sessions, ai:resume_session, ai:delete_session, ai:get_conversation_history. Add session selector UI in AIAssistant component showing previous conversations per cluster. Store database in Tauri app data directory using tauri::api::path::app_data_dir(). Implement migration system for schema updates.",
            "status": "done",
            "testStrategy": "Test session creation and persistence across app restarts. Verify conversation history correctly restores agent context. Test multi-cluster session isolation. Verify resume functionality maintains conversation state. Test database migrations. Verify session deletion cleanup.",
            "parentId": "undefined",
            "updatedAt": "2026-01-01T14:31:35.554Z"
          }
        ],
        "complexity": 9,
        "updatedAt": "2026-01-01T14:31:35.554Z"
      },
      {
        "id": "25",
        "title": "Implement MCP Server (2025-06-18 Spec) for IDE Integration",
        "description": "Create Model Context Protocol server compliant with 2025-06-18 spec featuring Elicitation, Resource Subscriptions, and OAuth 2.1 security",
        "details": "CRITICAL: Implement MCP spec version 2025-06-18 with new features: Elicitation, Resource Subscriptions, OAuth 2.1 + DPoP.\n\nRust Crates:\n- `turbomcp` or `pulseengine-mcp` for MCP server implementation\n- `pulseengine-mcp-auth` for OAuth 2.1 with DPoP (Demonstrating Proof-of-Possession)\n\nElicitation Implementation (Handling Ambiguity):\n- When tool encounters ambiguity (e.g., multiple services matching 'payment'), return ElicitationRequest\n- ElicitationRequest contains message and JSON schema for choices\n- Agent SDK passes to frontend for user disambiguation modal\n- User selection sent back to MCP server to proceed\n- Example: #[mcp_tool] async fn restart_service() returns ToolResult::Elicit(ElicitationRequest{...})\n\nResource Subscriptions (kube-rs Watcher Bridge):\n- Agent subscribes to MCP Resource URI: k8s://default/events\n- Rust backend spawns kube::runtime::watcher if not active\n- K8s events (Added/Modified/Deleted) transformed to MCP ResourceUpdated notifications\n- Agent receives 'interrupts' and can proactively act ('payment pod is crashing, shall I investigate?')\n- Enables proactive monitoring partner, not just passive dashboard\n\nSecurity (OAuth 2.1 Resource Server):\n- Implement Resource Indicators per 2025-06-18 spec\n- Tokens bound to specific cluster context\n- DPoP prevents token replay attacks\n- Use `pulseengine-mcp-auth` crate for implementation\n\nMCP Tools to Expose:\n- get_pods, get_deployments, get_services, get_logs (streaming), get_metrics, get_events\n- describe_resource, get_yaml, apply_yaml, delete_resource (with permission checks)\n- get_cluster_info, switch_namespace, list_namespaces\n\nTransport:\n- Stdio for local connections (recommended for desktop)\n- HTTP/SSE or Streamable HTTP (2025-03-26 spec) for remote\n\nSettings UI:\n- Enable/disable MCP server\n- Port configuration\n- Auth settings\n- Documentation links for VS Code, Cursor, Claude Code integration",
        "testStrategy": "Test MCP server with Claude Code CLI. Test Elicitation flow with ambiguous queries. Verify Resource Subscriptions deliver real-time updates. Test OAuth 2.1 + DPoP security. Test concurrent IDE connections. Performance test log streaming. Verify all tools return correct data.",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "MCP Server Core Implementation - turbomcp/pulseengine-mcp crate setup, server initialization, transport configuration (Stdio/HTTP)",
            "description": "Set up the MCP server foundation using turbomcp or pulseengine-mcp crate with stdio and HTTP transport support",
            "dependencies": [],
            "details": "Add turbomcp (or pulseengine-mcp) dependency to src-tauri/Cargo.toml. Create src-tauri/src/mcp/ directory structure with mod.rs, server.rs, transport.rs. Implement MCPServer struct in server.rs that wraps turbomcp server. Configure stdio transport for local connections (recommended for desktop IDE integration) and HTTP/SSE transport for remote connections. Create MCPServerManager similar to existing WatchManager pattern to manage server lifecycle. Add server state to AppState in src-tauri/src/k8s/client.rs. Implement server start/stop commands that can be invoked from frontend. Use Tauri's async runtime integration. Follow existing command patterns from src-tauri/src/commands/. Server should accept cluster context from AppState and use existing KubeClientManager for K8s operations.\n<info added on 2026-01-17T07:48:08.795Z>\nI need to analyze the codebase structure to provide specific implementation guidance for the MCP server core with CLI flag support.\n</info added on 2026-01-17T07:48:08.795Z>",
            "status": "done",
            "testStrategy": "Test server initialization with stdio transport. Verify server can start/stop cleanly. Test connection from Claude Code CLI using stdio. Verify server responds to basic MCP protocol handshake and capability negotiation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T10:41:01.202Z"
          },
          {
            "id": 2,
            "title": "Kubernetes Tools Exposure - Implement MCP tools: get_pods, get_deployments, get_services, get_logs, describe_resource, get_yaml",
            "description": "Expose core Kubernetes operations as MCP tools that IDEs can invoke",
            "dependencies": [
              1
            ],
            "details": "Create src-tauri/src/mcp/tools.rs implementing MCP tool handlers. Leverage existing commands from src-tauri/src/commands/resources.rs, logs.rs, etc. Implement these MCP tools using #[mcp_tool] macro: get_pods (reuse list_pods), get_deployments (reuse list_deployments), get_services (reuse list_services), get_logs (streaming, reuse LogStreamManager pattern), get_metrics (reuse MetricsCommands), get_events (use kube-rs watcher), describe_resource (generic resource describe), get_yaml (reuse get_resource_yaml), apply_yaml (reuse apply_resource_yaml with permission checks), delete_resource (reuse delete_resource with confirmation). Each tool should accept namespace parameter and return structured JSON responses. Use existing ListOptions, PodInfo, DeploymentInfo, ServiceInfo types for consistency. Add proper error handling and return descriptive error messages to IDE agent. Implement list_namespaces, switch_namespace, get_cluster_info tools for cluster context management.",
            "status": "done",
            "testStrategy": "Test each tool individually via Claude Code CLI. Verify get_pods returns correct pod list with proper structure. Test get_logs streams logs correctly. Verify describe_resource works for multiple resource types. Test apply_yaml with sample manifests. Verify permission checks prevent unauthorized operations.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T10:41:06.634Z"
          },
          {
            "id": 3,
            "title": "Elicitation System - Handle ambiguity with ElicitationRequest, frontend disambiguation modal, user selection flow",
            "description": "Implement elicitation mechanism for handling ambiguous tool requests requiring user disambiguation",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src-tauri/src/mcp/elicitation.rs. Define ElicitationRequest struct with message (e.g., 'Multiple services match payment') and JSON schema for choices. Implement elicitation logic in tools when ambiguity detected (e.g., restart_service('payment') finds multiple services). Return ToolResult::Elicit(ElicitationRequest{...}) instead of error. Agent SDK will receive elicitation and must pass to frontend. Create frontend components in src/components/mcp/ for disambiguation modal UI. Modal should display message and render choice options based on JSON schema. Implement Tauri event bridge to send elicitation requests to frontend and receive user selections back. Update MCP server to await user selection before proceeding with tool execution. Example flow: IDE calls restart_service -> backend finds 3 matches -> returns elicitation -> frontend shows modal -> user selects -> backend proceeds. Store elicitation state in MCPServerManager. Implement timeout handling (30s) if user doesn't respond.",
            "status": "pending",
            "testStrategy": "Test elicitation with ambiguous query like 'restart payment service' when multiple matches exist. Verify modal appears in frontend with correct choices. Test user selection flows back to backend correctly. Verify tool executes with selected choice. Test timeout behavior if user doesn't respond within 30s.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Resource Subscriptions Bridge - kube-rs Watcher to MCP ResourceUpdated notifications, real-time event streaming to agent",
            "description": "Bridge Kubernetes resource watchers to MCP resource subscriptions for proactive agent monitoring",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src-tauri/src/mcp/subscriptions.rs. Implement SubscriptionManager to track active MCP resource subscriptions (HashMap<String, SubscriptionHandle>). When agent subscribes to k8s://namespace/resource URI (e.g., k8s://default/pods, k8s://default/events), spawn kube::runtime::watcher if not already active. Reuse existing watch.rs patterns from src-tauri/src/commands/watch.rs. Transform K8s watcher events (Added/Modified/Deleted from kube::runtime::watcher::Event) to MCP ResourceUpdated notifications per 2025-06-18 spec. Send notifications to subscribed agents as 'interrupts' allowing proactive behavior (e.g., 'payment pod is crashing, shall I investigate?'). Support subscriptions for: pods, deployments, services, events, configmaps, secrets. Implement subscription lifecycle: subscribe, unsubscribe, list_subscriptions. Use tokio::spawn for watcher tasks. Handle backpressure if agent can't keep up with notifications. Implement reconnection logic if watcher stream breaks. Store active watchers in SubscriptionManager to share across multiple agent subscriptions to same resource.",
            "status": "pending",
            "testStrategy": "Test agent subscribing to k8s://default/pods. Verify ResourceUpdated notifications sent when pods are created/modified/deleted. Test multiple concurrent subscriptions to different resources. Verify watcher is shared when multiple agents subscribe to same resource. Test unsubscribe cleans up watcher if no more subscribers. Verify proactive notifications work (create crashing pod, verify agent receives events).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "OAuth 2.1 + DPoP Security - pulseengine-mcp-auth integration, token binding to cluster context, DPoP implementation",
            "description": "Implement OAuth 2.1 resource server with DPoP for secure MCP server access",
            "dependencies": [
              1
            ],
            "details": "Add pulseengine-mcp-auth dependency to src-tauri/Cargo.toml for OAuth 2.1 + DPoP support. Create src-tauri/src/mcp/auth.rs implementing OAuth 2.1 resource server per 2025-06-18 spec. Implement Resource Indicators (RFC 8707) to bind tokens to specific cluster context. Configure DPoP (Demonstrating Proof-of-Possession) to prevent token replay attacks. DPoP requires client to prove possession of private key for each request. Implement token validation middleware for MCP server that checks: 1) Token is valid OAuth 2.1 access token, 2) Token has correct resource indicator for current cluster, 3) DPoP proof is valid and matches token. Store cluster-token bindings in secure storage using tauri-plugin-store. Implement authorization checks for destructive operations (delete, apply_yaml) requiring elevated permissions. Add auth configuration to server settings: enable/disable auth, OAuth provider endpoint, allowed scopes. For local stdio connections, optionally bypass auth (configurable). For HTTP/remote connections, enforce auth by default. Integrate with existing AppState to access cluster context.",
            "status": "pending",
            "testStrategy": "Test OAuth 2.1 token validation. Verify tokens bound to cluster context are rejected if used with different cluster. Test DPoP proof validation prevents token replay. Test authorization checks for destructive operations. Verify local stdio connections work with auth disabled. Test remote HTTP connections require valid auth. Performance test auth middleware overhead.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Settings UI & Documentation - Enable/disable toggle, port configuration, connection guides for VS Code/Cursor/Claude Code",
            "description": "Build settings UI and documentation for MCP server configuration and IDE integration",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create src/app/settings/mcp/page.tsx for MCP server settings page. Implement UI controls: Enable/Disable MCP Server toggle, Port configuration for HTTP transport (default 3000), Transport selection (Stdio/HTTP/Both), Auth settings (Enable OAuth 2.1, Configure DPoP), Connection status indicator (running/stopped). Add server logs viewer showing recent MCP server activity. Create connection guides panel with tabs for VS Code, Cursor, Claude Code. For VS Code/Cursor: document .mcp/config.json setup with stdio command to launch Kubeli's MCP server. For Claude Code: document CLI integration with --mcp-server flag. Include copy-to-clipboard buttons for config snippets. Add troubleshooting section for common connection issues. Implement Tauri commands in src-tauri/src/commands/mcp.rs for: start_mcp_server, stop_mcp_server, get_mcp_status, get_mcp_config, update_mcp_config. Store MCP settings in tauri-plugin-store. Add MCP settings link to main settings navigation. Implement auto-start option (start MCP server when Kubeli launches). Add connection test button that verifies IDE can reach MCP server.\n<info added on 2026-01-17T07:48:28.828Z>\nI'll analyze the codebase to understand the current structure and provide a specific, implementation-focused update.\n</info added on 2026-01-17T07:48:28.828Z>\n<info added on 2026-01-18T10:42:05.507Z>\nIDE integration UI and config installers are implemented in Settings (MCP tab) with Tauri MCP commands for IDE detection/install/uninstall and path detection. Remaining scope: server enable/disable, port/auth settings, and docs for 2025-06-18 security/features.\n</info added on 2026-01-18T10:42:05.507Z>",
            "status": "pending",
            "testStrategy": "Test settings UI controls update MCP server configuration. Verify enable/disable toggle starts/stops server. Test port configuration changes take effect on restart. Verify connection guides display correct config snippets for each IDE. Test connection test button successfully validates connectivity. Test auto-start option launches server on Kubeli startup. Verify settings persist across app restarts.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "updatedAt": "2026-01-18T10:41:06.634Z"
      },
      {
        "id": "26",
        "title": "Implement Visual Resource Relationship Diagram with Elkjs",
        "description": "Build high-performance interactive diagram using React Flow + Elkjs optimized for 1000+ nodes at 60 FPS",
        "details": "CRITICAL: Use Elkjs (NOT Dagre) for layout - Elkjs supports compound/nested nodes essential for Namespace and Node groupings.\n\nLayout Engine Selection:\n- Dagre: Fast but NO compound node support\n- Elkjs: Layered layouts with robust nested/compound nodes - REQUIRED for microservices visualization\n\nPerformance Optimizations (Target: 1000+ nodes @ 60 FPS):\n1. Web Worker: Offload Elkjs layout calculation to worker thread (off-main-thread architecture)\n2. React.memo: Wrap ALL custom Node components to prevent unnecessary re-renders\n3. Zustand State Management: External to React render cycle\n   - nodes array in React Flow = lightweight positional data only\n   - Heavy metadata (labels, annotations, conditions) in Zustand store\n   - Nodes subscribe to specific state slices: useStore(state => state.nodes[id])\n4. Level of Detail (LOD): Zoom-based rendering\n   - High zoom: Full details (metrics, status icons, labels)\n   - Low zoom: Simplified 'Dot' representation\n\nGraph Generation (Rust Backend):\nCreate src-tauri/src/graph/topology.rs with relationship discovery algorithms:\n1. OwnerReferences (Explicit): O(N) - metadata.ownerReferences contains UID\n   - controller: true  Solid 'Ownership' line\n   - controller: false  Dashed 'Reference' line\n2. Label Selectors (Implicit): O(N*M) optimized with BTreeMap indexes\n   - Service  Pod edges via spec.selector\n3. Volume Associations: Parse spec.volumes array for Pod  PVC  PV edges\n\nOutput: GraphData { nodes: [], edges: [] } sent to frontend via Tauri command\n\nFrontend Implementation:\n- src/components/features/visualization/ResourceDiagram.tsx\n- src/lib/workers/layout-worker.ts (Web Worker for Elkjs)\n- Custom node components for each K8s resource type with status indicators\n- Edge styling: owns (solid), selects (dashed), mounts (dotted), exposes (colored)\n\nFeatures:\n- Namespace-scoped and cluster-wide views\n- Compound nodes for Namespaces and Nodes\n- Click-to-navigate to resource details\n- Minimap for large clusters\n- Filter by resource type or label\n- Search to highlight specific resources\n- Export as PNG/SVG\n- Real-time updates via kube-rs watchers",
        "testStrategy": "Performance test with 1000+ nodes - must maintain 60 FPS. Test Web Worker layout calculation doesn't block UI. Verify all relationship types (OwnerReferences, Selectors, Volumes) display correctly. Test LOD transitions are smooth. Test compound node grouping for Namespaces. Navigation from diagram to resource details. Export functionality.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Rust Graph Topology Generator Module",
            "description": "Implement relationship discovery algorithms for OwnerReferences, Label Selectors, and Volume Associations in Rust backend",
            "dependencies": [],
            "details": "Create src-tauri/src/graph/topology.rs with GraphData structure containing nodes and edges arrays. Implement three relationship discovery algorithms: (1) OwnerReferences parser - O(N) algorithm that extracts metadata.ownerReferences.uid, distinguishes controller:true (solid ownership line) from controller:false (dashed reference line), (2) Label Selector matcher - O(N*M) algorithm optimized with BTreeMap indexes to match Service spec.selector to Pod labels, (3) Volume Association parser - traverses spec.volumes array to create PodPVCPV edges. Add Tauri command generate_resource_graph(namespace: Option<String>) -> Result<GraphData, String> that fetches all resources via kube-rs and returns serialized graph. Include edge types in output: 'owns' (solid), 'selects' (dashed), 'mounts' (dotted), 'exposes' (colored).",
            "status": "pending",
            "testStrategy": "Unit test each algorithm with mock K8s resource data. Test OwnerReferences with controller true/false variants. Test Label Selector matching with complex selectors. Test Volume associations with PVC/PV chains. Integration test with minikube cluster containing 50+ resources to verify O(N) performance.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Setup Web Worker with Elkjs Layout Engine",
            "description": "Create Web Worker to offload Elkjs layout calculation from main thread, implementing message-based communication",
            "dependencies": [
              1
            ],
            "details": "Create src/lib/workers/layout-worker.ts that imports elkjs library and implements off-main-thread layout calculation. Add npm dependencies: 'elkjs': '^0.9.3', '@types/web-worker': '^5.0.0'. Worker receives GraphData message containing nodes/edges arrays, runs Elkjs layered layout algorithm with compound node support enabled (for Namespace and Node groupings), and posts back positioned nodes. Configure Elkjs options: algorithm: 'layered', hierarchyHandling: 'INCLUDE_CHILDREN', nodeSpacing: 50, edgeSpacing: 20. Create TypeScript types for worker messages: LayoutRequest { type: 'layout', data: GraphData }, LayoutResponse { type: 'complete', nodes: PositionedNode[] }. Handle worker errors and timeouts (10s max). Add webpack/vite configuration to bundle worker separately.",
            "status": "pending",
            "testStrategy": "Test worker instantiation and message passing. Verify layout calculation with 1000+ node graph completes in <2s off main thread. Test compound node positioning for Namespaces. Profile main thread during layout to confirm non-blocking execution. Test worker error handling with invalid graph data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement React Flow Base Component with Zustand Integration",
            "description": "Build ResourceDiagram.tsx with React Flow setup, Zustand state management for metadata, and lightweight node positioning",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/components/features/visualization/ResourceDiagram.tsx using '@xyflow/react': '^12.0.0' library. Implement Zustand store src/lib/stores/diagram-store.ts for graph metadata (separate from React Flow state): node labels, annotations, status indicators, K8s resource references. React Flow nodes array contains ONLY: id, position {x,y}, type. Custom nodes subscribe to diagram store slices via useStore(state => state.nodes[id]) for metadata. Initialize React Flow with: fitView on mount, interactive pan/zoom, minimap, controls. On component mount: (1) call Tauri command generate_resource_graph(), (2) send GraphData to layout-worker, (3) on worker response, update React Flow nodes with positions. Implement namespace filter dropdown that triggers re-fetch and re-layout. Add loading skeleton during layout calculation.",
            "status": "pending",
            "testStrategy": "Test component renders with empty state. Verify Tauri command integration fetches graph data. Test worker communication with message passing. Verify Zustand store updates trigger node re-renders. Test namespace filter triggers re-fetch. Profile render performance with 1000 nodes - target <16ms per frame.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Custom Resource Node Components with React.memo",
            "description": "Create resource-type specific node components for Pod, Service, Deployment, etc. with status indicators and memoization",
            "dependencies": [
              3
            ],
            "details": "Create src/components/features/visualization/nodes/ directory with individual files: PodNode.tsx, ServiceNode.tsx, DeploymentNode.tsx, ConfigMapNode.tsx, SecretNode.tsx, PVCNode.tsx, NamespaceCompoundNode.tsx. Each component wrapped with React.memo() to prevent unnecessary re-renders. Nodes display: resource icon (lucide-react), name (truncated at 20 chars with tooltip), status indicator dot (green=healthy, yellow=warning, red=error, gray=unknown). Status derived from K8s conditions (Ready, Available, etc.) fetched from diagram store. Implement click handler that navigates to ResourceDetail view using existing router pattern from Dashboard.tsx. Compound nodes (NamespaceCompoundNode) render as rounded rectangles containing child nodes. Add hover effect with elevation shadow. Size: regular nodes 120x60px, compound nodes auto-sized by Elkjs. Register all node types in React Flow nodeTypes prop.",
            "status": "pending",
            "testStrategy": "Test each node component renders with mock data. Verify React.memo prevents re-renders when unrelated state changes. Test status indicator colors match K8s resource conditions. Test click navigation to ResourceDetail. Test compound node grouping for Namespaces. Measure render time for 1000 nodes - must achieve 60 FPS (16ms/frame).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Level of Detail (LOD) Rendering System",
            "description": "Add zoom-based rendering that shows full details at high zoom and simplified dots at low zoom with smooth transitions",
            "dependencies": [
              4
            ],
            "details": "Implement zoom detection in ResourceDiagram.tsx using React Flow useViewport() hook. Define zoom thresholds: highDetail (zoom >= 1.0), mediumDetail (0.5 <= zoom < 1.0), lowDetail (zoom < 0.5). Create three rendering modes: (1) High zoom: full node components with icons, labels, status (default), (2) Medium zoom: simplified node with name only, no icon, (3) Low zoom: colored dot (8px circle) colored by status. Implement smooth transitions using CSS transitions (300ms ease-in-out) on node scale/opacity. Store current LOD level in Zustand diagram store to batch re-renders. Optimize by conditionally rendering node internals based on LOD level. Add zoom controls (buttons: Fit View, Zoom In, Zoom Out, Reset). Test transition smoothness during zoom - must maintain 60 FPS.",
            "status": "pending",
            "testStrategy": "Test zoom threshold detection at 0.3, 0.7, 1.2 zoom levels. Verify correct rendering mode for each threshold. Test transition smoothness - profile FPS during zoom animation. Test with 1000+ nodes - LOD must maintain 60 FPS at all zoom levels. Verify simplified dots are correctly colored by status.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add Advanced Features: Minimap, Search, Filters, Export, Real-time Updates",
            "description": "Implement minimap navigation, resource search/highlight, type/label filters, PNG/SVG export, and real-time updates via kube-rs watchers",
            "dependencies": [
              5
            ],
            "details": "Add React Flow MiniMap component in bottom-right corner (200x150px) with node colors matching status. Implement search bar with debounced input (300ms) that highlights matching nodes via React Flow setNodes() with selected:true. Create filter panel with: (1) resource type multi-select (Pod, Service, Deployment, etc.), (2) label selector input (key=value format), (3) namespace dropdown (already exists). Filtered nodes hidden via display:none CSS. Add export buttons: (1) PNG - use react-flow-renderer toDataURL(), (2) SVG - use react-flow-renderer toSVG(). Implement real-time updates by creating Tauri command watch_resources_for_graph(namespace: Option<String>) using kube-rs watch API, sends events via Tauri event system, frontend subscribes and incrementally updates diagram store without full re-layout (only update affected nodes). Add edge styling configuration: owns (solid 2px), selects (dashed 1px), mounts (dotted 1px), exposes (colored by service type).",
            "status": "pending",
            "testStrategy": "Test minimap navigation syncs with main viewport. Test search highlights correct nodes with partial name match. Test filters hide/show nodes correctly. Test export generates valid PNG (min 1920x1080) and SVG files. Test real-time updates by creating/deleting pods - verify incremental update without flicker. Test with 1000+ nodes - all features must maintain 60 FPS.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "updatedAt": "2025-12-30T04:36:11.970Z"
      },
      {
        "id": "27",
        "title": "Implement i18n Internationalization with next-intl",
        "description": "Add complete internationalization support for the entire application with English and German translations",
        "details": "Implement i18n using next-intl library for static Next.js export compatibility with Tauri. Create I18nProvider component with locale detection and persistence. Add translation files for EN and DE covering: navigation items, Dashboard resource views (40+ views), ResourceList component (table columns, empty messages, watch/refresh buttons), Sidebar, Settings panel, AI Assistant, Terminal, Port Forward panel, Update checker, and all dialogs. Create translateColumns() helper for dynamic column translation. Update all components to use useTranslations() hook.",
        "testStrategy": "Verify all UI elements display translated text. Test language switching persists across sessions. Verify TypeScript compilation passes. Test all 40+ Dashboard views show translated columns and empty messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "updatedAt": "2026-01-16T12:00:00.000Z"
      },
      {
        "id": "28",
        "title": "Fix Unused Provider Field Warning in AgentSession",
        "description": "Use the provider field in AgentSession struct for session listing and add provider info to SessionInfo",
        "details": "Fix Rust compiler warning about unused 'provider' field in AgentSession struct. Update list_sessions() to return provider information alongside session ID and cluster context. Add get_session_provider() method for future use. Update SessionInfo struct in both Rust backend (src-tauri/src/ai/commands.rs) and TypeScript frontend (src/lib/tauri/commands.ts) to include the provider field (AiCliProvider type).",
        "testStrategy": "Verify cargo build shows no warnings. Verify npm run typecheck passes. Test aiListSessions returns provider info.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 2,
        "updatedAt": "2026-01-16T12:30:00.000Z"
      },
      {
        "id": "29",
        "title": "Stabilize pod watch lifecycle with error recovery",
        "description": "Ensure pod watch sessions recover from errors and clean up correctly.",
        "details": "In `src-tauri/src/commands/watch.rs`, emit a terminal event on watch errors and ensure sessions are removed when the stream ends. In `src/lib/hooks/useK8sResources.ts`, handle `WatchEvent::Error` by setting `isWatching` false, surfacing the error state, and retrying with bounded backoff or falling back to polling. Ensure `stopWatch` is called on unmount and on watch failure so the backend session is cleaned up.",
        "testStrategy": "Simulate watch failures by disconnecting the cluster. Verify the UI shows an error and recovers by reconnecting or polling. Confirm `task-master list` shows no leaked watch sessions in logs.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "updatedAt": "2026-01-18T11:05:08.715Z"
      },
      {
        "id": "30",
        "title": "Batch log streaming updates to reduce UI churn",
        "description": "Buffer log stream events and flush in batches to keep the UI responsive with high-volume logs.",
        "details": "Add a small in-memory buffer in `src/lib/hooks/useLogs.ts` to accumulate log lines and flush them on an interval (e.g. 100250ms) instead of per-line state updates. Keep the ring buffer size capped (maxLines) without repeated array copies. Optionally add a backend-side batch mode in `src-tauri/src/commands/logs.rs` for large streams.",
        "testStrategy": "Stream logs from a noisy pod and verify the UI remains responsive, CPU usage drops, and log order is preserved. Confirm maxLines cap still works.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "updatedAt": "2026-01-18T10:37:19.182Z"
      },
      {
        "id": "32",
        "title": "Add caching and request dedup for resource fetching",
        "description": "Reduce repeated network calls and improve perceived performance by caching resource lists.",
        "details": "Adopt `@tanstack/react-query` (already in dependencies) for `useK8sResources` and related hooks. Add a shared `QueryClient` with sensible `staleTime`/`cacheTime`, and convert list commands to `useQuery` calls. Ensure namespace changes invalidate caches and that watch events update the cache instead of local component state.",
        "testStrategy": "Navigate between views repeatedly and confirm requests are deduped. Verify cache invalidation on namespace change and watch updates updating cached data.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "updatedAt": "2026-01-18T10:37:19.182Z"
      },
      {
        "id": "33",
        "title": "Parallelize multi-namespace listing with bounded concurrency",
        "description": "Speed up list operations that iterate across namespaces by running requests concurrently with limits.",
        "details": "In `src-tauri/src/commands/resources.rs`, replace sequential namespace loops with `futures::stream::iter(...).buffer_unordered(N)` for pods, deployments, services, configmaps, and secrets. Keep concurrency bounded (e.g. 510) to avoid API throttling. Add tracing around total duration.",
        "testStrategy": "Benchmark listing on a cluster with many namespaces and confirm list latency improves without triggering API throttling.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "updatedAt": "2026-01-18T10:50:38.168Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-18T12:34:58.000Z",
      "taskCount": 32,
      "completedCount": 28,
      "tags": [
        "master"
      ]
    }
  }
}
