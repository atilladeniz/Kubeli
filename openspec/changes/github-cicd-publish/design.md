## Context

Kubeli releases are currently built entirely on the developer's local macOS machine via `make build-deploy`, which chains: version bump → macOS build + sign → Windows cross-compile (cargo-xwin) → FTP deploy (latest.json + artifacts) → changelog generation (Claude CLI) → SBOM → Astro landing page → GitHub release creation.

This works but has key limitations:
- **No Linux builds** — cross-compilation for Linux isn't set up
- **Windows cross-compilation is fragile** — depends on cargo-xwin + LLVM toolchain on macOS
- **Non-reproducible** — no CI trail, depends on local machine state
- **Single point of failure** — only one machine can release

macOS signing + notarization can be done in CI by exporting the Apple Developer certificate as a .p12 file and storing it as a GitHub Secret. Other Tauri projects (Cap, Rivet, Cardo) do this successfully. The existing disabled `release.yml` already had the secrets structure prepared.

## Goals / Non-Goals

**Goals:**
- All platforms (macOS aarch64 + x86_64, Windows, Linux) built in CI on GitHub Actions
- macOS signed + notarized in CI via exported certificate and App Store Connect API key
- CI triggered by `v*` tag push
- Dual updater endpoints: FTP (primary) + GitHub Releases (fallback) for redundancy
- Changelog extracted from `CHANGELOG.md` for release notes
- GitHub Release created, populated, and published automatically
- FTP deployment for update server and landing page
- Local workflow reduced to: version bump → changelog → commit → tag push

**Non-Goals:**
- Windows Authenticode signing (not currently done, out of scope)
- Modifying the version bump process (stays manual/local)
- Changing the Astro landing page build/deploy (separate concern)

## Decisions

### 1. Trigger: `v*` tag push

**Choice:** The publish workflow triggers on `push: tags: ['v*']`.

**Alternatives considered:**
- **`release: [created]`**: Requires local draft release creation, adds a manual step.
- **`workflow_dispatch`** (Cap pattern): Fully manual, loses automation benefit.
- **Commit message match**: GitHub Actions can't reliably filter on commit message content.

**Rationale:** Simplest trigger. The developer pushes a `v*` tag as the last step of the local workflow. CI does everything from there. This is the standard pattern used by Cardo, PraccJS, and Rivet.

### 2. Workflow architecture: create-release → matrix build → finalize

**Choice:** One `publish.yml` with 3 job stages:
1. `create-release`: Creates a draft GitHub Release, extracts version and changelog
2. `build`: Matrix job across 4 platform targets, each uploading directly to the draft release via `releaseId`
3. `finalize`: Assembles FTP `latest.json`, deploys to FTP, publishes the release

**Rationale:** Draft release created first so build jobs can upload directly via `tauri-apps/tauri-action@v0` with `releaseId`. Matrix parallelizes all 4 builds. Finalize waits for all builds before deploying and publishing.

### 3. Platform matrix: 4 targets

**Choice:**
```yaml
matrix:
  include:
    - platform: macos-latest
      args: '--target aarch64-apple-darwin'
    - platform: macos-latest
      args: '--target x86_64-apple-darwin'
    - platform: windows-latest
      args: ''
    - platform: ubuntu-22.04
      args: ''
```

`fail-fast: false` ensures one platform failure doesn't abort the others.

### 4. macOS signing + notarization in CI

**Choice:** Export Apple Developer ID certificate as base64 .p12 → `APPLE_CERTIFICATE` secret. Notarization via App Store Connect API key → `APPLE_API_ISSUER`, `APPLE_API_KEY`, `APPLE_API_KEY_PATH` secrets.

The `tauri-apps/tauri-action` handles certificate import and notarization internally when these env vars are set. For `APPLE_API_KEY_PATH`, the .p8 file content is stored in `APPLE_API_KEY` secret and written to a temp file during CI.

**Reference:** Cap (CapSoftware) and Rivet (Ironclad) both use this approach successfully.

### 5. Build jobs upload directly to release via `releaseId`

**Choice:** Each build job uses `tauri-apps/tauri-action@v0` with `releaseId` from the create-release job and `tagName` for URL construction. Each job sets `uploadUpdaterJson: true` to auto-aggregate the GitHub-hosted `latest.json`.

**Rationale:** Direct upload eliminates the upload-artifact → download-artifact → gh release upload dance. tauri-action handles asset naming, signature upload, and `latest.json` aggregation automatically.

### 6. Dual updater endpoints: FTP (primary) + GitHub Releases (fallback)

**Choice:** `tauri.conf.json` updater endpoints:
1. `https://api.atilla.app/kubeli/updates/latest.json` (FTP, custom URLs)
2. `https://github.com/atilladeniz/Kubeli/releases/latest/download/latest.json` (GitHub, auto-generated)

Two separate `latest.json` files with different download URLs. Tauri tries in order, auto-fallback.

- **GitHub `latest.json`**: Auto-generated by tauri-action with GitHub Release download URLs
- **FTP `latest.json`**: Manually assembled in finalize job with FTP server URLs

### 7. FTP deployment: curl from finalize job

**Choice:** Same curl-based FTP uploads as current Makefile. Credentials as GitHub Secrets.

### 8. Changelog: Extracted from CHANGELOG.md

**Choice:** CI extracts the version section from `CHANGELOG.md` in the tagged commit. Developer generates changelog locally with Claude CLI before committing.

### 9. Existing `release.yml` replaced

**Choice:** Delete the disabled `release.yml` and replace with new `publish.yml`.

## Risks / Trade-offs

**[Apple certificate in CI]**
→ Mitigation: Certificate stored as encrypted GitHub Secret, only exposed during workflow runs. Same approach used by Cap, Rivet, and many other Tauri projects. Rotate certificate if compromised.

**[Notarization may timeout in CI]**
→ Mitigation: Apple notarization typically takes 2-5 minutes. tauri-action handles the wait. If Apple's servers are slow, the job may timeout — use `retryAttempts: 1` on tauri-action.

**[CI build times]**
→ Trade-off: macOS builds ~8-12min, Windows ~10-15min, Linux ~5-10min. All parallel. Rust caching via `swatinem/rust-cache` mitigates cold builds.

**[FTP credentials in GitHub Secrets]**
→ Mitigation: Standard practice. Encrypted at rest.

**[Race condition in latest.json aggregation]**
→ Mitigation: tauri-action retries `latest.json` upload at least once. The finalize job's FTP `latest.json` is assembled after all builds complete, so no race condition for the primary updater endpoint.

## Migration Plan

1. **Phase 1 — Setup**: Export Apple certificate, add all GitHub Secrets, create `publish.yml`
2. **Phase 2 — Validate**: Test with a patch release, verify all platforms build and deploy correctly
3. **Phase 3 — Simplify**: Update Makefile to remove Windows cross-compile, FTP deploy. Keep `make build-deploy-legacy` as fallback.
4. **Rollback**: Old `make build-deploy` works throughout transition since no local tooling is removed.

## Open Questions

- Should `sbom.yml` be triggered as part of publish or kept as a separate workflow?
- Should the Astro landing page deploy also move to CI?
