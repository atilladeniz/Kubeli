## ADDED Requirements

### Requirement: Publish workflow triggers on draft release creation

The system SHALL provide a GitHub Actions workflow (`.github/workflows/publish.yml`) that triggers on the `release: [created]` event. The workflow SHALL only proceed when the release tag matches the `v*` pattern.

#### Scenario: Draft release created with macOS artifacts

- **WHEN** a draft GitHub Release is created with a tag matching `v*` and macOS artifacts (`.dmg`, `.app.tar.gz`, `.app.tar.gz.sig`) are attached
- **THEN** the publish workflow starts, building Windows and Linux artifacts in parallel

#### Scenario: Non-release event

- **WHEN** a push, PR, or other non-release event occurs
- **THEN** the publish workflow SHALL NOT trigger

### Requirement: Windows build job produces signed NSIS installer

The workflow SHALL include a `build-windows` job running on `windows-latest` that builds a Tauri NSIS installer for `x86_64-pc-windows-msvc`. The build SHALL use `tauri-apps/tauri-action@v0`. The installer SHALL be signed with the Tauri updater private key (`TAURI_SIGNING_PRIVATE_KEY` secret) to produce a `.exe.sig` file.

#### Scenario: Successful Windows build

- **WHEN** the `build-windows` job runs
- **THEN** the job produces `Kubeli_{version}_x64-setup.exe` and `Kubeli_{version}_x64-setup.exe.sig` and uploads both as GitHub Actions artifacts

#### Scenario: Windows build failure

- **WHEN** the Windows build fails (compilation error, missing dependency)
- **THEN** the job fails, the `finalize` job does not run, and the GitHub Release remains in draft state

### Requirement: Linux build job produces AppImage

The workflow SHALL include a `build-linux` job running on `ubuntu-22.04` that builds a Tauri AppImage for `x86_64-unknown-linux-gnu`. The build SHALL install required system dependencies (`libwebkit2gtk-4.1-dev`, `libappindicator3-dev`, `librsvg2-dev`, `patchelf`). The AppImage SHALL be signed with the Tauri updater private key.

#### Scenario: Successful Linux build

- **WHEN** the `build-linux` job runs
- **THEN** the job produces `Kubeli_{version}_amd64.AppImage`, `Kubeli_{version}_amd64.AppImage.sig`, and `Kubeli_{version}_amd64.deb`, and uploads all as GitHub Actions artifacts

#### Scenario: Linux system dependencies installed

- **WHEN** the Linux build job starts on `ubuntu-22.04`
- **THEN** the job installs `libwebkit2gtk-4.1-dev`, `libappindicator3-dev`, `librsvg2-dev`, and `patchelf` before building

### Requirement: Rust and Node.js caching for CI performance

Both build jobs SHALL use `swatinem/rust-cache@v2` for Rust dependency caching (workspace: `src-tauri`) and `actions/setup-node@v6` with `cache: 'npm'` for Node.js dependency caching.

#### Scenario: Cached build

- **WHEN** a build runs with a warm cache from a previous run
- **THEN** Rust compilation and npm install times are reduced compared to a cold build

#### Scenario: Clean build

- **WHEN** no cache exists (first run or cache evicted)
- **THEN** the build completes successfully without caching, populating the cache for subsequent runs

### Requirement: Build jobs upload artifacts directly to GitHub Release

Each build job SHALL use `tauri-apps/tauri-action@v0` with `releaseId` (from the draft release) and `tagName` (for URL construction) to upload build artifacts directly to the GitHub Release. This eliminates the need for intermediate workflow artifacts.

#### Scenario: Windows artifacts on release after build

- **WHEN** the `build-windows` job completes
- **THEN** the GitHub Release contains Windows `.exe`, `.exe.sig`, and the Windows platform entry is merged into the GitHub-hosted `latest.json`

#### Scenario: Linux artifacts on release after build

- **WHEN** the `build-linux` job completes
- **THEN** the GitHub Release contains Linux `.AppImage`, `.AppImage.sig`, `.deb`, and the Linux platform entry is merged into the GitHub-hosted `latest.json`

### Requirement: Dual updater endpoints with automatic failover

The `tauri.conf.json` updater configuration SHALL specify two endpoints in the `endpoints` array. Tauri's updater tries endpoints in order and falls back to the next on failure.

1. **Primary (FTP)**: `https://api.atilla.app/kubeli/updates/latest.json` — download URLs point to the FTP server
2. **Fallback (GitHub)**: `https://github.com/atilladeniz/Kubeli/releases/latest/download/latest.json` — download URLs point to GitHub Release assets, auto-generated by tauri-action

#### Scenario: FTP server available

- **WHEN** the app checks for updates and the FTP server responds
- **THEN** the updater uses the FTP `latest.json` and downloads artifacts from the FTP server

#### Scenario: FTP server down, GitHub available

- **WHEN** the app checks for updates and the FTP server is unreachable
- **THEN** the updater falls back to the GitHub `latest.json` and downloads artifacts from GitHub Releases

#### Scenario: Both endpoints down

- **WHEN** the app checks for updates and both endpoints are unreachable
- **THEN** the updater reports no update available and retries on the next check interval

### Requirement: GitHub-hosted updater manifest via tauri-action

Each build job SHALL set `uploadUpdaterJson: true` on `tauri-apps/tauri-action@v0`. The action auto-generates a `latest.json` with GitHub Release download URLs and aggregates platform entries across jobs by downloading, merging, and re-uploading the `latest.json` release asset.

#### Scenario: GitHub latest.json aggregated

- **WHEN** both `build-windows` and `build-linux` jobs complete
- **THEN** the GitHub Release contains a `latest.json` with platform entries for `windows-x86_64` and `linux-x86_64`, each with GitHub download URLs and correct signatures

### Requirement: FTP updater manifest assembled in finalize job

The `finalize` job SHALL construct a separate `latest.json` with FTP download URLs. The manifest SHALL include entries for `darwin-aarch64`, `darwin-x86_64` (both pointing to the macOS `.app.tar.gz`), `windows-x86_64` (pointing to the Windows `.exe`), and `linux-x86_64` (pointing to the Linux `.AppImage`). Each entry SHALL include the platform's signature read from the corresponding `.sig` file downloaded from the GitHub Release.

#### Scenario: FTP latest.json generated with correct URLs

- **WHEN** the finalize job assembles `latest.json` for FTP
- **THEN** each platform entry's `url` points to `https://{DEPLOY_API_URL}/Kubeli_{version}_{artifact}` and `signature` contains the full content of the corresponding `.sig` file

#### Scenario: FTP latest.json includes macOS from local build

- **WHEN** the finalize job downloads macOS `.app.tar.gz.sig` from the GitHub Release
- **THEN** the `darwin-aarch64` and `darwin-x86_64` entries are included with FTP download URLs and macOS signature

### Requirement: FTP deployment of update files

The `finalize` job SHALL upload the following files to the FTP update server using `curl --ftp-create-dirs -T` with credentials from GitHub Secrets (`FTP_HOST`, `FTP_USER`, `FTP_PASSWORD`, `DEPLOY_API_FTP_PATH`): versioned Windows `.exe` + `.exe.sig`, versioned Linux `.AppImage` + `.AppImage.sig`, versioned macOS `.app.tar.gz` + `.app.tar.gz.sig` (downloaded from the release), and `latest.json`.

#### Scenario: Successful FTP upload

- **WHEN** FTP credentials are valid and the server is reachable
- **THEN** all update files are uploaded to the configured FTP path, and `latest.json` is available at `https://{DEPLOY_API_URL}/latest.json`

#### Scenario: FTP upload failure

- **WHEN** the FTP upload fails (credentials invalid, server unreachable)
- **THEN** the job fails with a clear error message, the GitHub Release remains in draft, and no partial `latest.json` is deployed

### Requirement: Landing page installer deployment

The `finalize` job SHALL upload the macOS DMG, Windows EXE, and Linux AppImage to the landing page FTP path (`DEPLOY_LANDING_FTP_PATH`). Each file SHALL be uploaded both with a versioned filename and as a `Kubeli_latest_*` alias.

#### Scenario: Landing page files updated

- **WHEN** the finalize job completes FTP uploads
- **THEN** the landing page FTP path contains `Kubeli_{version}_aarch64.dmg`, `Kubeli_latest.dmg`, `Kubeli_{version}_x64-setup.exe`, `Kubeli_latest_x64-setup.exe`, `Kubeli_{version}_amd64.AppImage`, and `Kubeli_latest_amd64.AppImage`

### Requirement: Changelog extracted and applied to release notes

The `finalize` job SHALL extract the changelog section for the current version from `CHANGELOG.md` in the repository. The extraction SHALL match the `## [{version}]` header and capture all content until the next `## [` header. The extracted content SHALL be used to update the GitHub Release body.

#### Scenario: Changelog section found

- **WHEN** `CHANGELOG.md` contains a section matching `## [{version}] - {date}`
- **THEN** the release body is updated with "## What's Changed\n\n{changelog content}\n\n**Full Changelog**: {compare URL}"

#### Scenario: Changelog section not found

- **WHEN** `CHANGELOG.md` does not contain a section for the current version
- **THEN** the release body falls back to "See [CHANGELOG.md](...) for details."

### Requirement: GitHub Release published after finalize

The `finalize` job SHALL mark the draft GitHub Release as published (non-draft) after all artifacts are uploaded, `latest.json` is deployed, and release notes are set.

#### Scenario: Release published

- **WHEN** all finalize steps complete successfully
- **THEN** the GitHub Release transitions from draft to published, making it visible to users and triggering any downstream workflows (e.g., `sbom.yml`)

### Requirement: GitHub Secrets configuration

The workflow SHALL require the following secrets to be configured in the GitHub repository settings:

| Secret | Purpose |
|--------|---------|
| `TAURI_SIGNING_PRIVATE_KEY` | Tauri updater signing key |
| `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` | Signing key password |
| `FTP_HOST` | FTP server hostname |
| `FTP_USER` | FTP username |
| `FTP_PASSWORD` | FTP password |
| `DEPLOY_API_FTP_PATH` | FTP path for update files |
| `DEPLOY_API_URL` | Public URL for update endpoint |
| `DEPLOY_LANDING_FTP_PATH` | FTP path for landing page installers |

#### Scenario: Missing secret

- **WHEN** a required secret is not configured
- **THEN** the workflow step that uses it fails with a clear error referencing the missing secret name
